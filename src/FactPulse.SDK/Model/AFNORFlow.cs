// <auto-generated>
/*
 * FactPulse REST API
 *
 *  REST API for electronic invoicing in France: Factur-X, AFNOR PDP/PA, electronic signatures.  ## üéØ Main Features  ### üìÑ Factur-X Invoice Generation - **Formats**: XML only or PDF/A-3 with embedded XML - **Profiles**: MINIMUM, BASIC, EN16931, EXTENDED - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **üÜï Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### ‚úÖ Validation and Compliance - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata, electronic signatures - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules) - **Asynchronous Processing**: Celery support for heavy validations (VeraPDF)  ### üì° AFNOR PDP/PA Integration (XP Z12-013) - **Flow Submission**: Send invoices to Partner Dematerialization Platforms - **Flow Search**: View submitted invoices - **Download**: Retrieve PDF/A-3 with XML - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user (stored credentials or zero-storage)  ### ‚úçÔ∏è PDF Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification - **Certificate Generation**: Self-signed X.509 certificates for testing  ### üîÑ Asynchronous Processing - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **No timeout**: Ideal for large files or heavy validations  ## üîí Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### üîë Method 1: `/api/token/` API (Recommended)  **URL:** `https://factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - ‚úÖ Full automation (CI/CD, scripts) - ‚úÖ Programmatic token management - ‚úÖ Refresh token support for automatic access renewal - ‚úÖ Easy integration in any language/tool  #### üñ•Ô∏è Method 2: Dashboard Generation (Alternative)  **URL:** https://factpulse.fr/api/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - ‚úÖ Quick for API testing - ‚úÖ No password required - ‚úÖ Simple visual interface  **Disadvantages:** - ‚ùå Requires manual action - ‚ùå No refresh token - ‚ùå Less suited for automation  ### üìö Full Documentation  For more information on authentication and API usage: https://factpulse.fr/documentation-api/     
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@factpulse.fr
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using FactPulse.SDK.Client;

namespace FactPulse.SDK.Model
{
    /// <summary>
    /// The properties of a Flow resource
    /// </summary>
    public partial class AFNORFlow : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AFNORFlow" /> class.
        /// </summary>
        /// <param name="submittedAt">The flow submission date and time (the date and time when the flow was created on the system) </param>
        /// <param name="updatedAt">The last update date and time of the flow. When the flow is submitted updatedAt is equal to submittedAt. When the flow acknowledgment status is changed updatedAt date and time is updated. </param>
        /// <param name="flowId">Unique identifier supporting UUID but not only, for flexibility purpose</param>
        /// <param name="trackingId">Unique identifier supporting UUID but not only, for flexibility purpose</param>
        /// <param name="flowType">flowType</param>
        /// <param name="processingRule">processingRule</param>
        /// <param name="processingRuleSource">Says whether the processing rule has been computed or the processing rule was an input parameter</param>
        /// <param name="flowDirection">flowDirection</param>
        /// <param name="flowSyntax">flowSyntax</param>
        /// <param name="flowProfile">flowProfile</param>
        /// <param name="acknowledgement">acknowledgement</param>
        [JsonConstructor]
        public AFNORFlow(Option<DateTime?> submittedAt = default, Option<DateTime?> updatedAt = default, Option<string?> flowId = default, Option<string?> trackingId = default, Option<AFNORFlowType?> flowType = default, Option<AFNORProcessingRule?> processingRule = default, Option<ProcessingRuleSourceEnum?> processingRuleSource = default, Option<AFNORFlowDirection?> flowDirection = default, Option<AFNORFlowSyntax?> flowSyntax = default, Option<AFNORFlowProfile?> flowProfile = default, Option<AFNORAcknowledgement?> acknowledgement = default)
        {
            SubmittedAtOption = submittedAt;
            UpdatedAtOption = updatedAt;
            FlowIdOption = flowId;
            TrackingIdOption = trackingId;
            FlowTypeOption = flowType;
            ProcessingRuleOption = processingRule;
            ProcessingRuleSourceOption = processingRuleSource;
            FlowDirectionOption = flowDirection;
            FlowSyntaxOption = flowSyntax;
            FlowProfileOption = flowProfile;
            AcknowledgementOption = acknowledgement;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of FlowType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AFNORFlowType?> FlowTypeOption { get; private set; }

        /// <summary>
        /// Gets or Sets FlowType
        /// </summary>
        [JsonPropertyName("flowType")]
        public AFNORFlowType? FlowType { get { return this.FlowTypeOption; } set { this.FlowTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of ProcessingRule
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AFNORProcessingRule?> ProcessingRuleOption { get; private set; }

        /// <summary>
        /// Gets or Sets ProcessingRule
        /// </summary>
        [JsonPropertyName("processingRule")]
        public AFNORProcessingRule? ProcessingRule { get { return this.ProcessingRuleOption; } set { this.ProcessingRuleOption = new(value); } }

        /// <summary>
        /// Says whether the processing rule has been computed or the processing rule was an input parameter
        /// </summary>
        /// <value>Says whether the processing rule has been computed or the processing rule was an input parameter</value>
        public enum ProcessingRuleSourceEnum
        {
            /// <summary>
            /// Enum Input for value: Input
            /// </summary>
            Input = 1,

            /// <summary>
            /// Enum Computed for value: Computed
            /// </summary>
            Computed = 2
        }

        /// <summary>
        /// Returns a <see cref="ProcessingRuleSourceEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static ProcessingRuleSourceEnum ProcessingRuleSourceEnumFromString(string value)
        {
            if (value.Equals("Input"))
                return ProcessingRuleSourceEnum.Input;

            if (value.Equals("Computed"))
                return ProcessingRuleSourceEnum.Computed;

            throw new NotImplementedException($"Could not convert value to type ProcessingRuleSourceEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="ProcessingRuleSourceEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static ProcessingRuleSourceEnum? ProcessingRuleSourceEnumFromStringOrDefault(string value)
        {
            if (value.Equals("Input"))
                return ProcessingRuleSourceEnum.Input;

            if (value.Equals("Computed"))
                return ProcessingRuleSourceEnum.Computed;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="ProcessingRuleSourceEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string ProcessingRuleSourceEnumToJsonValue(ProcessingRuleSourceEnum? value)
        {
            if (value == ProcessingRuleSourceEnum.Input)
                return "Input";

            if (value == ProcessingRuleSourceEnum.Computed)
                return "Computed";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of ProcessingRuleSource
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ProcessingRuleSourceEnum?> ProcessingRuleSourceOption { get; private set; }

        /// <summary>
        /// Says whether the processing rule has been computed or the processing rule was an input parameter
        /// </summary>
        /// <value>Says whether the processing rule has been computed or the processing rule was an input parameter</value>
        [JsonPropertyName("processingRuleSource")]
        public ProcessingRuleSourceEnum? ProcessingRuleSource { get { return this.ProcessingRuleSourceOption; } set { this.ProcessingRuleSourceOption = new(value); } }

        /// <summary>
        /// Used to track the state of FlowDirection
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AFNORFlowDirection?> FlowDirectionOption { get; private set; }

        /// <summary>
        /// Gets or Sets FlowDirection
        /// </summary>
        [JsonPropertyName("flowDirection")]
        public AFNORFlowDirection? FlowDirection { get { return this.FlowDirectionOption; } set { this.FlowDirectionOption = new(value); } }

        /// <summary>
        /// Used to track the state of FlowSyntax
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AFNORFlowSyntax?> FlowSyntaxOption { get; private set; }

        /// <summary>
        /// Gets or Sets FlowSyntax
        /// </summary>
        [JsonPropertyName("flowSyntax")]
        public AFNORFlowSyntax? FlowSyntax { get { return this.FlowSyntaxOption; } set { this.FlowSyntaxOption = new(value); } }

        /// <summary>
        /// Used to track the state of FlowProfile
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AFNORFlowProfile?> FlowProfileOption { get; private set; }

        /// <summary>
        /// Gets or Sets FlowProfile
        /// </summary>
        [JsonPropertyName("flowProfile")]
        public AFNORFlowProfile? FlowProfile { get { return this.FlowProfileOption; } set { this.FlowProfileOption = new(value); } }

        /// <summary>
        /// Used to track the state of SubmittedAt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> SubmittedAtOption { get; private set; }

        /// <summary>
        /// The flow submission date and time (the date and time when the flow was created on the system) 
        /// </summary>
        /// <value>The flow submission date and time (the date and time when the flow was created on the system) </value>
        [JsonPropertyName("submittedAt")]
        public DateTime? SubmittedAt { get { return this.SubmittedAtOption; } set { this.SubmittedAtOption = new(value); } }

        /// <summary>
        /// Used to track the state of UpdatedAt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> UpdatedAtOption { get; private set; }

        /// <summary>
        /// The last update date and time of the flow. When the flow is submitted updatedAt is equal to submittedAt. When the flow acknowledgment status is changed updatedAt date and time is updated. 
        /// </summary>
        /// <value>The last update date and time of the flow. When the flow is submitted updatedAt is equal to submittedAt. When the flow acknowledgment status is changed updatedAt date and time is updated. </value>
        [JsonPropertyName("updatedAt")]
        public DateTime? UpdatedAt { get { return this.UpdatedAtOption; } set { this.UpdatedAtOption = new(value); } }

        /// <summary>
        /// Used to track the state of FlowId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> FlowIdOption { get; private set; }

        /// <summary>
        /// Unique identifier supporting UUID but not only, for flexibility purpose
        /// </summary>
        /// <value>Unique identifier supporting UUID but not only, for flexibility purpose</value>
        [JsonPropertyName("flowId")]
        public string? FlowId { get { return this.FlowIdOption; } set { this.FlowIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of TrackingId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TrackingIdOption { get; private set; }

        /// <summary>
        /// Unique identifier supporting UUID but not only, for flexibility purpose
        /// </summary>
        /// <value>Unique identifier supporting UUID but not only, for flexibility purpose</value>
        [JsonPropertyName("trackingId")]
        public string? TrackingId { get { return this.TrackingIdOption; } set { this.TrackingIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of Acknowledgement
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AFNORAcknowledgement?> AcknowledgementOption { get; private set; }

        /// <summary>
        /// Gets or Sets Acknowledgement
        /// </summary>
        [JsonPropertyName("acknowledgement")]
        public AFNORAcknowledgement? Acknowledgement { get { return this.AcknowledgementOption; } set { this.AcknowledgementOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class AFNORFlow {\n");
            sb.Append("  SubmittedAt: ").Append(SubmittedAt).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("  FlowId: ").Append(FlowId).Append("\n");
            sb.Append("  TrackingId: ").Append(TrackingId).Append("\n");
            sb.Append("  FlowType: ").Append(FlowType).Append("\n");
            sb.Append("  ProcessingRule: ").Append(ProcessingRule).Append("\n");
            sb.Append("  ProcessingRuleSource: ").Append(ProcessingRuleSource).Append("\n");
            sb.Append("  FlowDirection: ").Append(FlowDirection).Append("\n");
            sb.Append("  FlowSyntax: ").Append(FlowSyntax).Append("\n");
            sb.Append("  FlowProfile: ").Append(FlowProfile).Append("\n");
            sb.Append("  Acknowledgement: ").Append(Acknowledgement).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // FlowId (string) maxLength
            if (this.FlowId != null && this.FlowId.Length > 36)
            {
                yield return new ValidationResult("Invalid value for FlowId, length must be less than 36.", new [] { "FlowId" });
            }

            // TrackingId (string) maxLength
            if (this.TrackingId != null && this.TrackingId.Length > 36)
            {
                yield return new ValidationResult("Invalid value for TrackingId, length must be less than 36.", new [] { "TrackingId" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="AFNORFlow" />
    /// </summary>
    public class AFNORFlowJsonConverter : JsonConverter<AFNORFlow>
    {
        /// <summary>
        /// The format to use to serialize SubmittedAt
        /// </summary>
        public static string SubmittedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize UpdatedAt
        /// </summary>
        public static string UpdatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="AFNORFlow" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override AFNORFlow Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<DateTime?> submittedAt = default;
            Option<DateTime?> updatedAt = default;
            Option<string?> flowId = default;
            Option<string?> trackingId = default;
            Option<AFNORFlowType?> flowType = default;
            Option<AFNORProcessingRule?> processingRule = default;
            Option<AFNORFlow.ProcessingRuleSourceEnum?> processingRuleSource = default;
            Option<AFNORFlowDirection?> flowDirection = default;
            Option<AFNORFlowSyntax?> flowSyntax = default;
            Option<AFNORFlowProfile?> flowProfile = default;
            Option<AFNORAcknowledgement?> acknowledgement = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "submittedAt":
                            submittedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "updatedAt":
                            updatedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "flowId":
                            flowId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "trackingId":
                            trackingId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "flowType":
                            string? flowTypeRawValue = utf8JsonReader.GetString();
                            if (flowTypeRawValue != null)
                                flowType = new Option<AFNORFlowType?>(AFNORFlowTypeValueConverter.FromStringOrDefault(flowTypeRawValue));
                            break;
                        case "processingRule":
                            string? processingRuleRawValue = utf8JsonReader.GetString();
                            if (processingRuleRawValue != null)
                                processingRule = new Option<AFNORProcessingRule?>(AFNORProcessingRuleValueConverter.FromStringOrDefault(processingRuleRawValue));
                            break;
                        case "processingRuleSource":
                            string? processingRuleSourceRawValue = utf8JsonReader.GetString();
                            if (processingRuleSourceRawValue != null)
                                processingRuleSource = new Option<AFNORFlow.ProcessingRuleSourceEnum?>(AFNORFlow.ProcessingRuleSourceEnumFromStringOrDefault(processingRuleSourceRawValue));
                            break;
                        case "flowDirection":
                            string? flowDirectionRawValue = utf8JsonReader.GetString();
                            if (flowDirectionRawValue != null)
                                flowDirection = new Option<AFNORFlowDirection?>(AFNORFlowDirectionValueConverter.FromStringOrDefault(flowDirectionRawValue));
                            break;
                        case "flowSyntax":
                            string? flowSyntaxRawValue = utf8JsonReader.GetString();
                            if (flowSyntaxRawValue != null)
                                flowSyntax = new Option<AFNORFlowSyntax?>(AFNORFlowSyntaxValueConverter.FromStringOrDefault(flowSyntaxRawValue));
                            break;
                        case "flowProfile":
                            string? flowProfileRawValue = utf8JsonReader.GetString();
                            if (flowProfileRawValue != null)
                                flowProfile = new Option<AFNORFlowProfile?>(AFNORFlowProfileValueConverter.FromStringOrDefault(flowProfileRawValue));
                            break;
                        case "acknowledgement":
                            acknowledgement = new Option<AFNORAcknowledgement?>(JsonSerializer.Deserialize<AFNORAcknowledgement>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (submittedAt.IsSet && submittedAt.Value == null)
                throw new ArgumentNullException(nameof(submittedAt), "Property is not nullable for class AFNORFlow.");

            if (updatedAt.IsSet && updatedAt.Value == null)
                throw new ArgumentNullException(nameof(updatedAt), "Property is not nullable for class AFNORFlow.");

            if (flowId.IsSet && flowId.Value == null)
                throw new ArgumentNullException(nameof(flowId), "Property is not nullable for class AFNORFlow.");

            if (trackingId.IsSet && trackingId.Value == null)
                throw new ArgumentNullException(nameof(trackingId), "Property is not nullable for class AFNORFlow.");

            if (flowType.IsSet && flowType.Value == null)
                throw new ArgumentNullException(nameof(flowType), "Property is not nullable for class AFNORFlow.");

            if (processingRule.IsSet && processingRule.Value == null)
                throw new ArgumentNullException(nameof(processingRule), "Property is not nullable for class AFNORFlow.");

            if (processingRuleSource.IsSet && processingRuleSource.Value == null)
                throw new ArgumentNullException(nameof(processingRuleSource), "Property is not nullable for class AFNORFlow.");

            if (flowDirection.IsSet && flowDirection.Value == null)
                throw new ArgumentNullException(nameof(flowDirection), "Property is not nullable for class AFNORFlow.");

            if (flowSyntax.IsSet && flowSyntax.Value == null)
                throw new ArgumentNullException(nameof(flowSyntax), "Property is not nullable for class AFNORFlow.");

            if (flowProfile.IsSet && flowProfile.Value == null)
                throw new ArgumentNullException(nameof(flowProfile), "Property is not nullable for class AFNORFlow.");

            if (acknowledgement.IsSet && acknowledgement.Value == null)
                throw new ArgumentNullException(nameof(acknowledgement), "Property is not nullable for class AFNORFlow.");

            return new AFNORFlow(submittedAt, updatedAt, flowId, trackingId, flowType, processingRule, processingRuleSource, flowDirection, flowSyntax, flowProfile, acknowledgement);
        }

        /// <summary>
        /// Serializes a <see cref="AFNORFlow" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="aFNORFlow"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, AFNORFlow aFNORFlow, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, aFNORFlow, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="AFNORFlow" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="aFNORFlow"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, AFNORFlow aFNORFlow, JsonSerializerOptions jsonSerializerOptions)
        {
            if (aFNORFlow.FlowIdOption.IsSet && aFNORFlow.FlowId == null)
                throw new ArgumentNullException(nameof(aFNORFlow.FlowId), "Property is required for class AFNORFlow.");

            if (aFNORFlow.TrackingIdOption.IsSet && aFNORFlow.TrackingId == null)
                throw new ArgumentNullException(nameof(aFNORFlow.TrackingId), "Property is required for class AFNORFlow.");

            if (aFNORFlow.AcknowledgementOption.IsSet && aFNORFlow.Acknowledgement == null)
                throw new ArgumentNullException(nameof(aFNORFlow.Acknowledgement), "Property is required for class AFNORFlow.");

            if (aFNORFlow.SubmittedAtOption.IsSet)
                writer.WriteString("submittedAt", aFNORFlow.SubmittedAtOption.Value!.Value.ToString(SubmittedAtFormat));

            if (aFNORFlow.UpdatedAtOption.IsSet)
                writer.WriteString("updatedAt", aFNORFlow.UpdatedAtOption.Value!.Value.ToString(UpdatedAtFormat));

            if (aFNORFlow.FlowIdOption.IsSet)
                writer.WriteString("flowId", aFNORFlow.FlowId);

            if (aFNORFlow.TrackingIdOption.IsSet)
                writer.WriteString("trackingId", aFNORFlow.TrackingId);

            if (aFNORFlow.FlowTypeOption.IsSet)
            {
                var flowTypeRawValue = AFNORFlowTypeValueConverter.ToJsonValue(aFNORFlow.FlowType!.Value);
                writer.WriteString("flowType", flowTypeRawValue);
            }
            if (aFNORFlow.ProcessingRuleOption.IsSet)
            {
                var processingRuleRawValue = AFNORProcessingRuleValueConverter.ToJsonValue(aFNORFlow.ProcessingRule!.Value);
                writer.WriteString("processingRule", processingRuleRawValue);
            }
            var processingRuleSourceRawValue = AFNORFlow.ProcessingRuleSourceEnumToJsonValue(aFNORFlow.ProcessingRuleSourceOption.Value!.Value);
            writer.WriteString("processingRuleSource", processingRuleSourceRawValue);
            if (aFNORFlow.FlowDirectionOption.IsSet)
            {
                var flowDirectionRawValue = AFNORFlowDirectionValueConverter.ToJsonValue(aFNORFlow.FlowDirection!.Value);
                writer.WriteString("flowDirection", flowDirectionRawValue);
            }
            if (aFNORFlow.FlowSyntaxOption.IsSet)
            {
                var flowSyntaxRawValue = AFNORFlowSyntaxValueConverter.ToJsonValue(aFNORFlow.FlowSyntax!.Value);
                writer.WriteString("flowSyntax", flowSyntaxRawValue);
            }
            if (aFNORFlow.FlowProfileOption.IsSet)
            {
                var flowProfileRawValue = AFNORFlowProfileValueConverter.ToJsonValue(aFNORFlow.FlowProfile!.Value);
                writer.WriteString("flowProfile", flowProfileRawValue);
            }
            if (aFNORFlow.AcknowledgementOption.IsSet)
            {
                writer.WritePropertyName("acknowledgement");
                JsonSerializer.Serialize(writer, aFNORFlow.Acknowledgement, jsonSerializerOptions);
            }
        }
    }
}
