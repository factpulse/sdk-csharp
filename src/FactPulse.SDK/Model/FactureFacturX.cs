// <auto-generated>
/*
 * FactPulse REST API
 *
 *  REST API for electronic invoicing in France: Factur-X, AFNOR PDP/PA, electronic signatures.  ## üéØ Main Features  ### üìÑ Factur-X Invoice Generation - **Formats**: XML only or PDF/A-3 with embedded XML - **Profiles**: MINIMUM, BASIC, EN16931, EXTENDED - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **üÜï Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### ‚úÖ Validation and Compliance - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata, electronic signatures - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules) - **Asynchronous Processing**: Celery support for heavy validations (VeraPDF)  ### üì° AFNOR PDP/PA Integration (XP Z12-013) - **Flow Submission**: Send invoices to Partner Dematerialization Platforms - **Flow Search**: View submitted invoices - **Download**: Retrieve PDF/A-3 with XML - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user (stored credentials or zero-storage)  ### ‚úçÔ∏è PDF Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification - **Certificate Generation**: Self-signed X.509 certificates for testing  ### üîÑ Asynchronous Processing - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **No timeout**: Ideal for large files or heavy validations  ## üîí Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### üîë Method 1: `/api/token/` API (Recommended)  **URL:** `https://www.factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://www.factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://www.factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://www.factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - ‚úÖ Full automation (CI/CD, scripts) - ‚úÖ Programmatic token management - ‚úÖ Refresh token support for automatic access renewal - ‚úÖ Easy integration in any language/tool  #### üñ•Ô∏è Method 2: Dashboard Generation (Alternative)  **URL:** https://www.factpulse.fr/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - ‚úÖ Quick for API testing - ‚úÖ No password required - ‚úÖ Simple visual interface  **Disadvantages:** - ‚ùå Requires manual action - ‚ùå No refresh token - ‚ùå Less suited for automation  ### üìö Full Documentation  For more information on authentication and API usage: https://www.factpulse.fr/documentation-api/     
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using FactPulse.SDK.Client;

namespace FactPulse.SDK.Model
{
    /// <summary>
    /// Data model for an invoice to be converted to Factur-X.
    /// </summary>
    public partial class FactureFacturX : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FactureFacturX" /> class.
        /// </summary>
        /// <param name="invoiceNumber">invoiceNumber</param>
        /// <param name="paymentDueDate">paymentDueDate</param>
        /// <param name="submissionMode">submissionMode</param>
        /// <param name="recipient">recipient</param>
        /// <param name="supplier">supplier</param>
        /// <param name="invoicingFramework">invoicingFramework</param>
        /// <param name="references">references</param>
        /// <param name="totals">totals</param>
        /// <param name="invoiceDate">invoiceDate</param>
        /// <param name="invoiceLines">invoiceLines</param>
        /// <param name="vatLines">vatLines</param>
        /// <param name="notes">notes</param>
        /// <param name="comment">comment</param>
        /// <param name="currentUserId">currentUserId</param>
        /// <param name="supplementaryAttachments">supplementaryAttachments</param>
        /// <param name="payee">payee</param>
        [JsonConstructor]
        public FactureFacturX(string invoiceNumber, string paymentDueDate, SubmissionMode submissionMode, Recipient recipient, Supplier supplier, InvoicingFramework invoicingFramework, InvoiceReferences references, InvoiceTotals totals, Option<string?> invoiceDate = default, Option<List<InvoiceLine>?> invoiceLines = default, Option<List<VATLine>?> vatLines = default, Option<List<InvoiceNote>?> notes = default, Option<string?> comment = default, Option<int?> currentUserId = default, Option<List<SupplementaryAttachment>?> supplementaryAttachments = default, Option<Payee?> payee = default)
        {
            InvoiceNumber = invoiceNumber;
            PaymentDueDate = paymentDueDate;
            SubmissionMode = submissionMode;
            Recipient = recipient;
            Supplier = supplier;
            InvoicingFramework = invoicingFramework;
            References = references;
            Totals = totals;
            InvoiceDateOption = invoiceDate;
            InvoiceLinesOption = invoiceLines;
            VatLinesOption = vatLines;
            NotesOption = notes;
            CommentOption = comment;
            CurrentUserIdOption = currentUserId;
            SupplementaryAttachmentsOption = supplementaryAttachments;
            PayeeOption = payee;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Gets or Sets SubmissionMode
        /// </summary>
        [JsonPropertyName("submission_mode")]
        public SubmissionMode SubmissionMode { get; set; }

        /// <summary>
        /// Gets or Sets InvoiceNumber
        /// </summary>
        [JsonPropertyName("invoice_number")]
        public string InvoiceNumber { get; set; }

        /// <summary>
        /// Gets or Sets PaymentDueDate
        /// </summary>
        [JsonPropertyName("payment_due_date")]
        public string PaymentDueDate { get; set; }

        /// <summary>
        /// Gets or Sets Recipient
        /// </summary>
        [JsonPropertyName("recipient")]
        public Recipient Recipient { get; set; }

        /// <summary>
        /// Gets or Sets Supplier
        /// </summary>
        [JsonPropertyName("supplier")]
        public Supplier Supplier { get; set; }

        /// <summary>
        /// Gets or Sets InvoicingFramework
        /// </summary>
        [JsonPropertyName("invoicing_framework")]
        public InvoicingFramework InvoicingFramework { get; set; }

        /// <summary>
        /// Gets or Sets References
        /// </summary>
        [JsonPropertyName("references")]
        public InvoiceReferences References { get; set; }

        /// <summary>
        /// Gets or Sets Totals
        /// </summary>
        [JsonPropertyName("totals")]
        public InvoiceTotals Totals { get; set; }

        /// <summary>
        /// Used to track the state of InvoiceDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> InvoiceDateOption { get; private set; }

        /// <summary>
        /// Gets or Sets InvoiceDate
        /// </summary>
        [JsonPropertyName("invoice_date")]
        public string? InvoiceDate { get { return this.InvoiceDateOption; } set { this.InvoiceDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of InvoiceLines
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<InvoiceLine>?> InvoiceLinesOption { get; private set; }

        /// <summary>
        /// Gets or Sets InvoiceLines
        /// </summary>
        [JsonPropertyName("invoice_lines")]
        public List<InvoiceLine>? InvoiceLines { get { return this.InvoiceLinesOption; } set { this.InvoiceLinesOption = new(value); } }

        /// <summary>
        /// Used to track the state of VatLines
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<VATLine>?> VatLinesOption { get; private set; }

        /// <summary>
        /// Gets or Sets VatLines
        /// </summary>
        [JsonPropertyName("vat_lines")]
        public List<VATLine>? VatLines { get { return this.VatLinesOption; } set { this.VatLinesOption = new(value); } }

        /// <summary>
        /// Used to track the state of Notes
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<InvoiceNote>?> NotesOption { get; private set; }

        /// <summary>
        /// Gets or Sets Notes
        /// </summary>
        [JsonPropertyName("notes")]
        public List<InvoiceNote>? Notes { get { return this.NotesOption; } set { this.NotesOption = new(value); } }

        /// <summary>
        /// Used to track the state of Comment
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> CommentOption { get; private set; }

        /// <summary>
        /// Gets or Sets Comment
        /// </summary>
        [JsonPropertyName("comment")]
        public string? Comment { get { return this.CommentOption; } set { this.CommentOption = new(value); } }

        /// <summary>
        /// Used to track the state of CurrentUserId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> CurrentUserIdOption { get; private set; }

        /// <summary>
        /// Gets or Sets CurrentUserId
        /// </summary>
        [JsonPropertyName("current_user_id")]
        public int? CurrentUserId { get { return this.CurrentUserIdOption; } set { this.CurrentUserIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of SupplementaryAttachments
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<SupplementaryAttachment>?> SupplementaryAttachmentsOption { get; private set; }

        /// <summary>
        /// Gets or Sets SupplementaryAttachments
        /// </summary>
        [JsonPropertyName("supplementary_attachments")]
        public List<SupplementaryAttachment>? SupplementaryAttachments { get { return this.SupplementaryAttachmentsOption; } set { this.SupplementaryAttachmentsOption = new(value); } }

        /// <summary>
        /// Used to track the state of Payee
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Payee?> PayeeOption { get; private set; }

        /// <summary>
        /// Gets or Sets Payee
        /// </summary>
        [JsonPropertyName("payee")]
        public Payee? Payee { get { return this.PayeeOption; } set { this.PayeeOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class FactureFacturX {\n");
            sb.Append("  InvoiceNumber: ").Append(InvoiceNumber).Append("\n");
            sb.Append("  PaymentDueDate: ").Append(PaymentDueDate).Append("\n");
            sb.Append("  SubmissionMode: ").Append(SubmissionMode).Append("\n");
            sb.Append("  Recipient: ").Append(Recipient).Append("\n");
            sb.Append("  Supplier: ").Append(Supplier).Append("\n");
            sb.Append("  InvoicingFramework: ").Append(InvoicingFramework).Append("\n");
            sb.Append("  References: ").Append(References).Append("\n");
            sb.Append("  Totals: ").Append(Totals).Append("\n");
            sb.Append("  InvoiceDate: ").Append(InvoiceDate).Append("\n");
            sb.Append("  InvoiceLines: ").Append(InvoiceLines).Append("\n");
            sb.Append("  VatLines: ").Append(VatLines).Append("\n");
            sb.Append("  Notes: ").Append(Notes).Append("\n");
            sb.Append("  Comment: ").Append(Comment).Append("\n");
            sb.Append("  CurrentUserId: ").Append(CurrentUserId).Append("\n");
            sb.Append("  SupplementaryAttachments: ").Append(SupplementaryAttachments).Append("\n");
            sb.Append("  Payee: ").Append(Payee).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="FactureFacturX" />
    /// </summary>
    public class FactureFacturXJsonConverter : JsonConverter<FactureFacturX>
    {
        /// <summary>
        /// Deserializes json to <see cref="FactureFacturX" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override FactureFacturX Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> invoiceNumber = default;
            Option<string?> paymentDueDate = default;
            Option<SubmissionMode?> submissionMode = default;
            Option<Recipient?> recipient = default;
            Option<Supplier?> supplier = default;
            Option<InvoicingFramework?> invoicingFramework = default;
            Option<InvoiceReferences?> references = default;
            Option<InvoiceTotals?> totals = default;
            Option<string?> invoiceDate = default;
            Option<List<InvoiceLine>?> invoiceLines = default;
            Option<List<VATLine>?> vatLines = default;
            Option<List<InvoiceNote>?> notes = default;
            Option<string?> comment = default;
            Option<int?> currentUserId = default;
            Option<List<SupplementaryAttachment>?> supplementaryAttachments = default;
            Option<Payee?> payee = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "invoice_number":
                            invoiceNumber = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "payment_due_date":
                            paymentDueDate = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "submission_mode":
                            string? submissionModeRawValue = utf8JsonReader.GetString();
                            if (submissionModeRawValue != null)
                                submissionMode = new Option<SubmissionMode?>(SubmissionModeValueConverter.FromStringOrDefault(submissionModeRawValue));
                            break;
                        case "recipient":
                            recipient = new Option<Recipient?>(JsonSerializer.Deserialize<Recipient>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "supplier":
                            supplier = new Option<Supplier?>(JsonSerializer.Deserialize<Supplier>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "invoicing_framework":
                            invoicingFramework = new Option<InvoicingFramework?>(JsonSerializer.Deserialize<InvoicingFramework>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "references":
                            references = new Option<InvoiceReferences?>(JsonSerializer.Deserialize<InvoiceReferences>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "totals":
                            totals = new Option<InvoiceTotals?>(JsonSerializer.Deserialize<InvoiceTotals>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "invoice_date":
                            invoiceDate = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "invoice_lines":
                            invoiceLines = new Option<List<InvoiceLine>?>(JsonSerializer.Deserialize<List<InvoiceLine>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "vat_lines":
                            vatLines = new Option<List<VATLine>?>(JsonSerializer.Deserialize<List<VATLine>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "notes":
                            notes = new Option<List<InvoiceNote>?>(JsonSerializer.Deserialize<List<InvoiceNote>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "comment":
                            comment = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "current_user_id":
                            currentUserId = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "supplementary_attachments":
                            supplementaryAttachments = new Option<List<SupplementaryAttachment>?>(JsonSerializer.Deserialize<List<SupplementaryAttachment>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "payee":
                            payee = new Option<Payee?>(JsonSerializer.Deserialize<Payee>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!invoiceNumber.IsSet)
                throw new ArgumentException("Property is required for class FactureFacturX.", nameof(invoiceNumber));

            if (!paymentDueDate.IsSet)
                throw new ArgumentException("Property is required for class FactureFacturX.", nameof(paymentDueDate));

            if (!submissionMode.IsSet)
                throw new ArgumentException("Property is required for class FactureFacturX.", nameof(submissionMode));

            if (!recipient.IsSet)
                throw new ArgumentException("Property is required for class FactureFacturX.", nameof(recipient));

            if (!supplier.IsSet)
                throw new ArgumentException("Property is required for class FactureFacturX.", nameof(supplier));

            if (!invoicingFramework.IsSet)
                throw new ArgumentException("Property is required for class FactureFacturX.", nameof(invoicingFramework));

            if (!references.IsSet)
                throw new ArgumentException("Property is required for class FactureFacturX.", nameof(references));

            if (!totals.IsSet)
                throw new ArgumentException("Property is required for class FactureFacturX.", nameof(totals));

            if (invoiceNumber.IsSet && invoiceNumber.Value == null)
                throw new ArgumentNullException(nameof(invoiceNumber), "Property is not nullable for class FactureFacturX.");

            if (paymentDueDate.IsSet && paymentDueDate.Value == null)
                throw new ArgumentNullException(nameof(paymentDueDate), "Property is not nullable for class FactureFacturX.");

            if (submissionMode.IsSet && submissionMode.Value == null)
                throw new ArgumentNullException(nameof(submissionMode), "Property is not nullable for class FactureFacturX.");

            if (recipient.IsSet && recipient.Value == null)
                throw new ArgumentNullException(nameof(recipient), "Property is not nullable for class FactureFacturX.");

            if (supplier.IsSet && supplier.Value == null)
                throw new ArgumentNullException(nameof(supplier), "Property is not nullable for class FactureFacturX.");

            if (invoicingFramework.IsSet && invoicingFramework.Value == null)
                throw new ArgumentNullException(nameof(invoicingFramework), "Property is not nullable for class FactureFacturX.");

            if (references.IsSet && references.Value == null)
                throw new ArgumentNullException(nameof(references), "Property is not nullable for class FactureFacturX.");

            if (totals.IsSet && totals.Value == null)
                throw new ArgumentNullException(nameof(totals), "Property is not nullable for class FactureFacturX.");

            if (invoiceDate.IsSet && invoiceDate.Value == null)
                throw new ArgumentNullException(nameof(invoiceDate), "Property is not nullable for class FactureFacturX.");

            if (invoiceLines.IsSet && invoiceLines.Value == null)
                throw new ArgumentNullException(nameof(invoiceLines), "Property is not nullable for class FactureFacturX.");

            if (vatLines.IsSet && vatLines.Value == null)
                throw new ArgumentNullException(nameof(vatLines), "Property is not nullable for class FactureFacturX.");

            if (notes.IsSet && notes.Value == null)
                throw new ArgumentNullException(nameof(notes), "Property is not nullable for class FactureFacturX.");

            return new FactureFacturX(invoiceNumber.Value!, paymentDueDate.Value!, submissionMode.Value!.Value!, recipient.Value!, supplier.Value!, invoicingFramework.Value!, references.Value!, totals.Value!, invoiceDate, invoiceLines, vatLines, notes, comment, currentUserId, supplementaryAttachments, payee);
        }

        /// <summary>
        /// Serializes a <see cref="FactureFacturX" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="factureFacturX"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, FactureFacturX factureFacturX, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, factureFacturX, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="FactureFacturX" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="factureFacturX"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, FactureFacturX factureFacturX, JsonSerializerOptions jsonSerializerOptions)
        {
            if (factureFacturX.InvoiceNumber == null)
                throw new ArgumentNullException(nameof(factureFacturX.InvoiceNumber), "Property is required for class FactureFacturX.");

            if (factureFacturX.PaymentDueDate == null)
                throw new ArgumentNullException(nameof(factureFacturX.PaymentDueDate), "Property is required for class FactureFacturX.");

            if (factureFacturX.Recipient == null)
                throw new ArgumentNullException(nameof(factureFacturX.Recipient), "Property is required for class FactureFacturX.");

            if (factureFacturX.Supplier == null)
                throw new ArgumentNullException(nameof(factureFacturX.Supplier), "Property is required for class FactureFacturX.");

            if (factureFacturX.InvoicingFramework == null)
                throw new ArgumentNullException(nameof(factureFacturX.InvoicingFramework), "Property is required for class FactureFacturX.");

            if (factureFacturX.References == null)
                throw new ArgumentNullException(nameof(factureFacturX.References), "Property is required for class FactureFacturX.");

            if (factureFacturX.Totals == null)
                throw new ArgumentNullException(nameof(factureFacturX.Totals), "Property is required for class FactureFacturX.");

            if (factureFacturX.InvoiceDateOption.IsSet && factureFacturX.InvoiceDate == null)
                throw new ArgumentNullException(nameof(factureFacturX.InvoiceDate), "Property is required for class FactureFacturX.");

            if (factureFacturX.InvoiceLinesOption.IsSet && factureFacturX.InvoiceLines == null)
                throw new ArgumentNullException(nameof(factureFacturX.InvoiceLines), "Property is required for class FactureFacturX.");

            if (factureFacturX.VatLinesOption.IsSet && factureFacturX.VatLines == null)
                throw new ArgumentNullException(nameof(factureFacturX.VatLines), "Property is required for class FactureFacturX.");

            if (factureFacturX.NotesOption.IsSet && factureFacturX.Notes == null)
                throw new ArgumentNullException(nameof(factureFacturX.Notes), "Property is required for class FactureFacturX.");

            writer.WriteString("invoice_number", factureFacturX.InvoiceNumber);

            writer.WriteString("payment_due_date", factureFacturX.PaymentDueDate);

            var submissionModeRawValue = SubmissionModeValueConverter.ToJsonValue(factureFacturX.SubmissionMode);
            writer.WriteString("submission_mode", submissionModeRawValue);

            writer.WritePropertyName("recipient");
            JsonSerializer.Serialize(writer, factureFacturX.Recipient, jsonSerializerOptions);
            writer.WritePropertyName("supplier");
            JsonSerializer.Serialize(writer, factureFacturX.Supplier, jsonSerializerOptions);
            writer.WritePropertyName("invoicing_framework");
            JsonSerializer.Serialize(writer, factureFacturX.InvoicingFramework, jsonSerializerOptions);
            writer.WritePropertyName("references");
            JsonSerializer.Serialize(writer, factureFacturX.References, jsonSerializerOptions);
            writer.WritePropertyName("totals");
            JsonSerializer.Serialize(writer, factureFacturX.Totals, jsonSerializerOptions);
            if (factureFacturX.InvoiceDateOption.IsSet)
                writer.WriteString("invoice_date", factureFacturX.InvoiceDate);

            if (factureFacturX.InvoiceLinesOption.IsSet)
            {
                writer.WritePropertyName("invoice_lines");
                JsonSerializer.Serialize(writer, factureFacturX.InvoiceLines, jsonSerializerOptions);
            }
            if (factureFacturX.VatLinesOption.IsSet)
            {
                writer.WritePropertyName("vat_lines");
                JsonSerializer.Serialize(writer, factureFacturX.VatLines, jsonSerializerOptions);
            }
            if (factureFacturX.NotesOption.IsSet)
            {
                writer.WritePropertyName("notes");
                JsonSerializer.Serialize(writer, factureFacturX.Notes, jsonSerializerOptions);
            }
            if (factureFacturX.CommentOption.IsSet)
                if (factureFacturX.CommentOption.Value != null)
                    writer.WriteString("comment", factureFacturX.Comment);
                else
                    writer.WriteNull("comment");

            if (factureFacturX.CurrentUserIdOption.IsSet)
                if (factureFacturX.CurrentUserIdOption.Value != null)
                    writer.WriteNumber("current_user_id", factureFacturX.CurrentUserIdOption.Value!.Value);
                else
                    writer.WriteNull("current_user_id");

            if (factureFacturX.SupplementaryAttachmentsOption.IsSet)
                if (factureFacturX.SupplementaryAttachmentsOption.Value != null)
                {
                    writer.WritePropertyName("supplementary_attachments");
                    JsonSerializer.Serialize(writer, factureFacturX.SupplementaryAttachments, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("supplementary_attachments");
            if (factureFacturX.PayeeOption.IsSet)
                if (factureFacturX.PayeeOption.Value != null)
                {
                    writer.WritePropertyName("payee");
                    JsonSerializer.Serialize(writer, factureFacturX.Payee, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("payee");
        }
    }
}
