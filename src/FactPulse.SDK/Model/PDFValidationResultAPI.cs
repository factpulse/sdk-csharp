// <auto-generated>
/*
 * FactPulse REST API
 *
 *  REST API for electronic invoicing in France: Factur-X, AFNOR PDP/PA, electronic signatures.  ## üéØ Main Features  ### üìÑ Factur-X Invoice Generation - **Formats**: XML only or PDF/A-3 with embedded XML - **Profiles**: MINIMUM, BASIC, EN16931, EXTENDED - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **üÜï Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### ‚úÖ Validation and Compliance - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata, electronic signatures - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules) - **Asynchronous Processing**: Celery support for heavy validations (VeraPDF)  ### üì° AFNOR PDP/PA Integration (XP Z12-013) - **Flow Submission**: Send invoices to Partner Dematerialization Platforms - **Flow Search**: View submitted invoices - **Download**: Retrieve PDF/A-3 with XML - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user (stored credentials or zero-storage)  ### ‚úçÔ∏è PDF Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification - **Certificate Generation**: Self-signed X.509 certificates for testing  ### üîÑ Asynchronous Processing - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **No timeout**: Ideal for large files or heavy validations  ## üîí Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### üîë Method 1: `/api/token/` API (Recommended)  **URL:** `https://www.factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://www.factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://www.factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://www.factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - ‚úÖ Full automation (CI/CD, scripts) - ‚úÖ Programmatic token management - ‚úÖ Refresh token support for automatic access renewal - ‚úÖ Easy integration in any language/tool  #### üñ•Ô∏è Method 2: Dashboard Generation (Alternative)  **URL:** https://www.factpulse.fr/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - ‚úÖ Quick for API testing - ‚úÖ No password required - ‚úÖ Simple visual interface  **Disadvantages:** - ‚ùå Requires manual action - ‚ùå No refresh token - ‚ùå Less suited for automation  ### üìö Full Documentation  For more information on authentication and API usage: https://www.factpulse.fr/documentation-api/     
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using FactPulse.SDK.Client;

namespace FactPulse.SDK.Model
{
    /// <summary>
    /// Complete result of a Factur-X PDF validation.
    /// </summary>
    public partial class PDFValidationResultAPI : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PDFValidationResultAPI" /> class.
        /// </summary>
        /// <param name="isCompliant">True if PDF complies with all criteria (XML, PDF/A, XMP)</param>
        /// <param name="xmlPresent">True if a Factur-X XML is embedded in the PDF</param>
        /// <param name="xmlCompliant">True if Factur-X XML complies with Schematron rules</param>
        /// <param name="pdfaCompliant">True if PDF is PDF/A compliant</param>
        /// <param name="xmpPresent">True if XMP metadata is present</param>
        /// <param name="xmpFacturxCompliant">True if XMP metadata contains Factur-X information</param>
        /// <param name="isSigned">True if PDF contains at least one signature</param>
        /// <param name="summaryMessage">Message summarizing the validation result</param>
        /// <param name="detectedProfile">detectedProfile</param>
        /// <param name="xmlErrors">List of XML validation errors</param>
        /// <param name="pdfaVersion">pdfaVersion</param>
        /// <param name="pdfaValidationMethod">Method used for PDF/A validation (metadata or verapdf) (default to &quot;metadata&quot;)</param>
        /// <param name="validatedRules">validatedRules</param>
        /// <param name="failedRules">failedRules</param>
        /// <param name="pdfaErrors">List of PDF/A compliance errors</param>
        /// <param name="pdfaWarnings">List of PDF/A warnings</param>
        /// <param name="xmpProfile">xmpProfile</param>
        /// <param name="xmpVersion">xmpVersion</param>
        /// <param name="xmpErrors">List of XMP metadata errors</param>
        /// <param name="xmpMetadata">XMP metadata extracted from PDF</param>
        /// <param name="signatureCount">Number of electronic signatures found (default to 0)</param>
        /// <param name="signatures">List of found signatures with their information</param>
        /// <param name="signatureErrors">List of errors during signature analysis</param>
        [JsonConstructor]
        public PDFValidationResultAPI(bool isCompliant, bool xmlPresent, bool xmlCompliant, bool pdfaCompliant, bool xmpPresent, bool xmpFacturxCompliant, bool isSigned, string summaryMessage, Option<string?> detectedProfile = default, Option<List<string>?> xmlErrors = default, Option<string?> pdfaVersion = default, Option<string?> pdfaValidationMethod = default, Option<int?> validatedRules = default, Option<int?> failedRules = default, Option<List<string>?> pdfaErrors = default, Option<List<string>?> pdfaWarnings = default, Option<string?> xmpProfile = default, Option<string?> xmpVersion = default, Option<List<string>?> xmpErrors = default, Option<Dictionary<string, Object>?> xmpMetadata = default, Option<int?> signatureCount = default, Option<List<SignatureInfoAPI>?> signatures = default, Option<List<string>?> signatureErrors = default)
        {
            IsCompliant = isCompliant;
            XmlPresent = xmlPresent;
            XmlCompliant = xmlCompliant;
            PdfaCompliant = pdfaCompliant;
            XmpPresent = xmpPresent;
            XmpFacturxCompliant = xmpFacturxCompliant;
            IsSigned = isSigned;
            SummaryMessage = summaryMessage;
            DetectedProfileOption = detectedProfile;
            XmlErrorsOption = xmlErrors;
            PdfaVersionOption = pdfaVersion;
            PdfaValidationMethodOption = pdfaValidationMethod;
            ValidatedRulesOption = validatedRules;
            FailedRulesOption = failedRules;
            PdfaErrorsOption = pdfaErrors;
            PdfaWarningsOption = pdfaWarnings;
            XmpProfileOption = xmpProfile;
            XmpVersionOption = xmpVersion;
            XmpErrorsOption = xmpErrors;
            XmpMetadataOption = xmpMetadata;
            SignatureCountOption = signatureCount;
            SignaturesOption = signatures;
            SignatureErrorsOption = signatureErrors;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// True if PDF complies with all criteria (XML, PDF/A, XMP)
        /// </summary>
        /// <value>True if PDF complies with all criteria (XML, PDF/A, XMP)</value>
        [JsonPropertyName("isCompliant")]
        public bool IsCompliant { get; set; }

        /// <summary>
        /// True if a Factur-X XML is embedded in the PDF
        /// </summary>
        /// <value>True if a Factur-X XML is embedded in the PDF</value>
        [JsonPropertyName("xmlPresent")]
        public bool XmlPresent { get; set; }

        /// <summary>
        /// True if Factur-X XML complies with Schematron rules
        /// </summary>
        /// <value>True if Factur-X XML complies with Schematron rules</value>
        [JsonPropertyName("xmlCompliant")]
        public bool XmlCompliant { get; set; }

        /// <summary>
        /// True if PDF is PDF/A compliant
        /// </summary>
        /// <value>True if PDF is PDF/A compliant</value>
        [JsonPropertyName("pdfaCompliant")]
        public bool PdfaCompliant { get; set; }

        /// <summary>
        /// True if XMP metadata is present
        /// </summary>
        /// <value>True if XMP metadata is present</value>
        [JsonPropertyName("xmpPresent")]
        public bool XmpPresent { get; set; }

        /// <summary>
        /// True if XMP metadata contains Factur-X information
        /// </summary>
        /// <value>True if XMP metadata contains Factur-X information</value>
        [JsonPropertyName("xmpFacturxCompliant")]
        public bool XmpFacturxCompliant { get; set; }

        /// <summary>
        /// True if PDF contains at least one signature
        /// </summary>
        /// <value>True if PDF contains at least one signature</value>
        [JsonPropertyName("isSigned")]
        public bool IsSigned { get; set; }

        /// <summary>
        /// Message summarizing the validation result
        /// </summary>
        /// <value>Message summarizing the validation result</value>
        [JsonPropertyName("summaryMessage")]
        public string SummaryMessage { get; set; }

        /// <summary>
        /// Used to track the state of DetectedProfile
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DetectedProfileOption { get; private set; }

        /// <summary>
        /// Gets or Sets DetectedProfile
        /// </summary>
        [JsonPropertyName("detectedProfile")]
        public string? DetectedProfile { get { return this.DetectedProfileOption; } set { this.DetectedProfileOption = new(value); } }

        /// <summary>
        /// Used to track the state of XmlErrors
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> XmlErrorsOption { get; private set; }

        /// <summary>
        /// List of XML validation errors
        /// </summary>
        /// <value>List of XML validation errors</value>
        [JsonPropertyName("xmlErrors")]
        public List<string>? XmlErrors { get { return this.XmlErrorsOption; } set { this.XmlErrorsOption = new(value); } }

        /// <summary>
        /// Used to track the state of PdfaVersion
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> PdfaVersionOption { get; private set; }

        /// <summary>
        /// Gets or Sets PdfaVersion
        /// </summary>
        [JsonPropertyName("pdfaVersion")]
        public string? PdfaVersion { get { return this.PdfaVersionOption; } set { this.PdfaVersionOption = new(value); } }

        /// <summary>
        /// Used to track the state of PdfaValidationMethod
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> PdfaValidationMethodOption { get; private set; }

        /// <summary>
        /// Method used for PDF/A validation (metadata or verapdf)
        /// </summary>
        /// <value>Method used for PDF/A validation (metadata or verapdf)</value>
        [JsonPropertyName("pdfaValidationMethod")]
        public string? PdfaValidationMethod { get { return this.PdfaValidationMethodOption; } set { this.PdfaValidationMethodOption = new(value); } }

        /// <summary>
        /// Used to track the state of ValidatedRules
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> ValidatedRulesOption { get; private set; }

        /// <summary>
        /// Gets or Sets ValidatedRules
        /// </summary>
        [JsonPropertyName("validatedRules")]
        public int? ValidatedRules { get { return this.ValidatedRulesOption; } set { this.ValidatedRulesOption = new(value); } }

        /// <summary>
        /// Used to track the state of FailedRules
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> FailedRulesOption { get; private set; }

        /// <summary>
        /// Gets or Sets FailedRules
        /// </summary>
        [JsonPropertyName("failedRules")]
        public int? FailedRules { get { return this.FailedRulesOption; } set { this.FailedRulesOption = new(value); } }

        /// <summary>
        /// Used to track the state of PdfaErrors
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> PdfaErrorsOption { get; private set; }

        /// <summary>
        /// List of PDF/A compliance errors
        /// </summary>
        /// <value>List of PDF/A compliance errors</value>
        [JsonPropertyName("pdfaErrors")]
        public List<string>? PdfaErrors { get { return this.PdfaErrorsOption; } set { this.PdfaErrorsOption = new(value); } }

        /// <summary>
        /// Used to track the state of PdfaWarnings
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> PdfaWarningsOption { get; private set; }

        /// <summary>
        /// List of PDF/A warnings
        /// </summary>
        /// <value>List of PDF/A warnings</value>
        [JsonPropertyName("pdfaWarnings")]
        public List<string>? PdfaWarnings { get { return this.PdfaWarningsOption; } set { this.PdfaWarningsOption = new(value); } }

        /// <summary>
        /// Used to track the state of XmpProfile
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> XmpProfileOption { get; private set; }

        /// <summary>
        /// Gets or Sets XmpProfile
        /// </summary>
        [JsonPropertyName("xmpProfile")]
        public string? XmpProfile { get { return this.XmpProfileOption; } set { this.XmpProfileOption = new(value); } }

        /// <summary>
        /// Used to track the state of XmpVersion
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> XmpVersionOption { get; private set; }

        /// <summary>
        /// Gets or Sets XmpVersion
        /// </summary>
        [JsonPropertyName("xmpVersion")]
        public string? XmpVersion { get { return this.XmpVersionOption; } set { this.XmpVersionOption = new(value); } }

        /// <summary>
        /// Used to track the state of XmpErrors
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> XmpErrorsOption { get; private set; }

        /// <summary>
        /// List of XMP metadata errors
        /// </summary>
        /// <value>List of XMP metadata errors</value>
        [JsonPropertyName("xmpErrors")]
        public List<string>? XmpErrors { get { return this.XmpErrorsOption; } set { this.XmpErrorsOption = new(value); } }

        /// <summary>
        /// Used to track the state of XmpMetadata
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, Object>?> XmpMetadataOption { get; private set; }

        /// <summary>
        /// XMP metadata extracted from PDF
        /// </summary>
        /// <value>XMP metadata extracted from PDF</value>
        [JsonPropertyName("xmpMetadata")]
        public Dictionary<string, Object>? XmpMetadata { get { return this.XmpMetadataOption; } set { this.XmpMetadataOption = new(value); } }

        /// <summary>
        /// Used to track the state of SignatureCount
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> SignatureCountOption { get; private set; }

        /// <summary>
        /// Number of electronic signatures found
        /// </summary>
        /// <value>Number of electronic signatures found</value>
        [JsonPropertyName("signatureCount")]
        public int? SignatureCount { get { return this.SignatureCountOption; } set { this.SignatureCountOption = new(value); } }

        /// <summary>
        /// Used to track the state of Signatures
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<SignatureInfoAPI>?> SignaturesOption { get; private set; }

        /// <summary>
        /// List of found signatures with their information
        /// </summary>
        /// <value>List of found signatures with their information</value>
        [JsonPropertyName("signatures")]
        public List<SignatureInfoAPI>? Signatures { get { return this.SignaturesOption; } set { this.SignaturesOption = new(value); } }

        /// <summary>
        /// Used to track the state of SignatureErrors
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> SignatureErrorsOption { get; private set; }

        /// <summary>
        /// List of errors during signature analysis
        /// </summary>
        /// <value>List of errors during signature analysis</value>
        [JsonPropertyName("signatureErrors")]
        public List<string>? SignatureErrors { get { return this.SignatureErrorsOption; } set { this.SignatureErrorsOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PDFValidationResultAPI {\n");
            sb.Append("  IsCompliant: ").Append(IsCompliant).Append("\n");
            sb.Append("  XmlPresent: ").Append(XmlPresent).Append("\n");
            sb.Append("  XmlCompliant: ").Append(XmlCompliant).Append("\n");
            sb.Append("  PdfaCompliant: ").Append(PdfaCompliant).Append("\n");
            sb.Append("  XmpPresent: ").Append(XmpPresent).Append("\n");
            sb.Append("  XmpFacturxCompliant: ").Append(XmpFacturxCompliant).Append("\n");
            sb.Append("  IsSigned: ").Append(IsSigned).Append("\n");
            sb.Append("  SummaryMessage: ").Append(SummaryMessage).Append("\n");
            sb.Append("  DetectedProfile: ").Append(DetectedProfile).Append("\n");
            sb.Append("  XmlErrors: ").Append(XmlErrors).Append("\n");
            sb.Append("  PdfaVersion: ").Append(PdfaVersion).Append("\n");
            sb.Append("  PdfaValidationMethod: ").Append(PdfaValidationMethod).Append("\n");
            sb.Append("  ValidatedRules: ").Append(ValidatedRules).Append("\n");
            sb.Append("  FailedRules: ").Append(FailedRules).Append("\n");
            sb.Append("  PdfaErrors: ").Append(PdfaErrors).Append("\n");
            sb.Append("  PdfaWarnings: ").Append(PdfaWarnings).Append("\n");
            sb.Append("  XmpProfile: ").Append(XmpProfile).Append("\n");
            sb.Append("  XmpVersion: ").Append(XmpVersion).Append("\n");
            sb.Append("  XmpErrors: ").Append(XmpErrors).Append("\n");
            sb.Append("  XmpMetadata: ").Append(XmpMetadata).Append("\n");
            sb.Append("  SignatureCount: ").Append(SignatureCount).Append("\n");
            sb.Append("  Signatures: ").Append(Signatures).Append("\n");
            sb.Append("  SignatureErrors: ").Append(SignatureErrors).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="PDFValidationResultAPI" />
    /// </summary>
    public class PDFValidationResultAPIJsonConverter : JsonConverter<PDFValidationResultAPI>
    {
        /// <summary>
        /// Deserializes json to <see cref="PDFValidationResultAPI" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override PDFValidationResultAPI Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<bool?> isCompliant = default;
            Option<bool?> xmlPresent = default;
            Option<bool?> xmlCompliant = default;
            Option<bool?> pdfaCompliant = default;
            Option<bool?> xmpPresent = default;
            Option<bool?> xmpFacturxCompliant = default;
            Option<bool?> isSigned = default;
            Option<string?> summaryMessage = default;
            Option<string?> detectedProfile = default;
            Option<List<string>?> xmlErrors = default;
            Option<string?> pdfaVersion = default;
            Option<string?> pdfaValidationMethod = default;
            Option<int?> validatedRules = default;
            Option<int?> failedRules = default;
            Option<List<string>?> pdfaErrors = default;
            Option<List<string>?> pdfaWarnings = default;
            Option<string?> xmpProfile = default;
            Option<string?> xmpVersion = default;
            Option<List<string>?> xmpErrors = default;
            Option<Dictionary<string, Object>?> xmpMetadata = default;
            Option<int?> signatureCount = default;
            Option<List<SignatureInfoAPI>?> signatures = default;
            Option<List<string>?> signatureErrors = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "isCompliant":
                            isCompliant = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "xmlPresent":
                            xmlPresent = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "xmlCompliant":
                            xmlCompliant = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "pdfaCompliant":
                            pdfaCompliant = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "xmpPresent":
                            xmpPresent = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "xmpFacturxCompliant":
                            xmpFacturxCompliant = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "isSigned":
                            isSigned = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "summaryMessage":
                            summaryMessage = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "detectedProfile":
                            detectedProfile = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "xmlErrors":
                            xmlErrors = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "pdfaVersion":
                            pdfaVersion = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "pdfaValidationMethod":
                            pdfaValidationMethod = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "validatedRules":
                            validatedRules = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "failedRules":
                            failedRules = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "pdfaErrors":
                            pdfaErrors = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "pdfaWarnings":
                            pdfaWarnings = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "xmpProfile":
                            xmpProfile = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "xmpVersion":
                            xmpVersion = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "xmpErrors":
                            xmpErrors = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "xmpMetadata":
                            xmpMetadata = new Option<Dictionary<string, Object>?>(JsonSerializer.Deserialize<Dictionary<string, Object>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "signatureCount":
                            signatureCount = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "signatures":
                            signatures = new Option<List<SignatureInfoAPI>?>(JsonSerializer.Deserialize<List<SignatureInfoAPI>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "signatureErrors":
                            signatureErrors = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!isCompliant.IsSet)
                throw new ArgumentException("Property is required for class PDFValidationResultAPI.", nameof(isCompliant));

            if (!xmlPresent.IsSet)
                throw new ArgumentException("Property is required for class PDFValidationResultAPI.", nameof(xmlPresent));

            if (!xmlCompliant.IsSet)
                throw new ArgumentException("Property is required for class PDFValidationResultAPI.", nameof(xmlCompliant));

            if (!pdfaCompliant.IsSet)
                throw new ArgumentException("Property is required for class PDFValidationResultAPI.", nameof(pdfaCompliant));

            if (!xmpPresent.IsSet)
                throw new ArgumentException("Property is required for class PDFValidationResultAPI.", nameof(xmpPresent));

            if (!xmpFacturxCompliant.IsSet)
                throw new ArgumentException("Property is required for class PDFValidationResultAPI.", nameof(xmpFacturxCompliant));

            if (!isSigned.IsSet)
                throw new ArgumentException("Property is required for class PDFValidationResultAPI.", nameof(isSigned));

            if (!summaryMessage.IsSet)
                throw new ArgumentException("Property is required for class PDFValidationResultAPI.", nameof(summaryMessage));

            if (isCompliant.IsSet && isCompliant.Value == null)
                throw new ArgumentNullException(nameof(isCompliant), "Property is not nullable for class PDFValidationResultAPI.");

            if (xmlPresent.IsSet && xmlPresent.Value == null)
                throw new ArgumentNullException(nameof(xmlPresent), "Property is not nullable for class PDFValidationResultAPI.");

            if (xmlCompliant.IsSet && xmlCompliant.Value == null)
                throw new ArgumentNullException(nameof(xmlCompliant), "Property is not nullable for class PDFValidationResultAPI.");

            if (pdfaCompliant.IsSet && pdfaCompliant.Value == null)
                throw new ArgumentNullException(nameof(pdfaCompliant), "Property is not nullable for class PDFValidationResultAPI.");

            if (xmpPresent.IsSet && xmpPresent.Value == null)
                throw new ArgumentNullException(nameof(xmpPresent), "Property is not nullable for class PDFValidationResultAPI.");

            if (xmpFacturxCompliant.IsSet && xmpFacturxCompliant.Value == null)
                throw new ArgumentNullException(nameof(xmpFacturxCompliant), "Property is not nullable for class PDFValidationResultAPI.");

            if (isSigned.IsSet && isSigned.Value == null)
                throw new ArgumentNullException(nameof(isSigned), "Property is not nullable for class PDFValidationResultAPI.");

            if (summaryMessage.IsSet && summaryMessage.Value == null)
                throw new ArgumentNullException(nameof(summaryMessage), "Property is not nullable for class PDFValidationResultAPI.");

            if (xmlErrors.IsSet && xmlErrors.Value == null)
                throw new ArgumentNullException(nameof(xmlErrors), "Property is not nullable for class PDFValidationResultAPI.");

            if (pdfaValidationMethod.IsSet && pdfaValidationMethod.Value == null)
                throw new ArgumentNullException(nameof(pdfaValidationMethod), "Property is not nullable for class PDFValidationResultAPI.");

            if (pdfaErrors.IsSet && pdfaErrors.Value == null)
                throw new ArgumentNullException(nameof(pdfaErrors), "Property is not nullable for class PDFValidationResultAPI.");

            if (pdfaWarnings.IsSet && pdfaWarnings.Value == null)
                throw new ArgumentNullException(nameof(pdfaWarnings), "Property is not nullable for class PDFValidationResultAPI.");

            if (xmpErrors.IsSet && xmpErrors.Value == null)
                throw new ArgumentNullException(nameof(xmpErrors), "Property is not nullable for class PDFValidationResultAPI.");

            if (xmpMetadata.IsSet && xmpMetadata.Value == null)
                throw new ArgumentNullException(nameof(xmpMetadata), "Property is not nullable for class PDFValidationResultAPI.");

            if (signatureCount.IsSet && signatureCount.Value == null)
                throw new ArgumentNullException(nameof(signatureCount), "Property is not nullable for class PDFValidationResultAPI.");

            if (signatures.IsSet && signatures.Value == null)
                throw new ArgumentNullException(nameof(signatures), "Property is not nullable for class PDFValidationResultAPI.");

            if (signatureErrors.IsSet && signatureErrors.Value == null)
                throw new ArgumentNullException(nameof(signatureErrors), "Property is not nullable for class PDFValidationResultAPI.");

            return new PDFValidationResultAPI(isCompliant.Value!.Value!, xmlPresent.Value!.Value!, xmlCompliant.Value!.Value!, pdfaCompliant.Value!.Value!, xmpPresent.Value!.Value!, xmpFacturxCompliant.Value!.Value!, isSigned.Value!.Value!, summaryMessage.Value!, detectedProfile, xmlErrors, pdfaVersion, pdfaValidationMethod, validatedRules, failedRules, pdfaErrors, pdfaWarnings, xmpProfile, xmpVersion, xmpErrors, xmpMetadata, signatureCount, signatures, signatureErrors);
        }

        /// <summary>
        /// Serializes a <see cref="PDFValidationResultAPI" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="pDFValidationResultAPI"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, PDFValidationResultAPI pDFValidationResultAPI, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, pDFValidationResultAPI, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="PDFValidationResultAPI" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="pDFValidationResultAPI"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, PDFValidationResultAPI pDFValidationResultAPI, JsonSerializerOptions jsonSerializerOptions)
        {
            if (pDFValidationResultAPI.SummaryMessage == null)
                throw new ArgumentNullException(nameof(pDFValidationResultAPI.SummaryMessage), "Property is required for class PDFValidationResultAPI.");

            if (pDFValidationResultAPI.XmlErrorsOption.IsSet && pDFValidationResultAPI.XmlErrors == null)
                throw new ArgumentNullException(nameof(pDFValidationResultAPI.XmlErrors), "Property is required for class PDFValidationResultAPI.");

            if (pDFValidationResultAPI.PdfaValidationMethodOption.IsSet && pDFValidationResultAPI.PdfaValidationMethod == null)
                throw new ArgumentNullException(nameof(pDFValidationResultAPI.PdfaValidationMethod), "Property is required for class PDFValidationResultAPI.");

            if (pDFValidationResultAPI.PdfaErrorsOption.IsSet && pDFValidationResultAPI.PdfaErrors == null)
                throw new ArgumentNullException(nameof(pDFValidationResultAPI.PdfaErrors), "Property is required for class PDFValidationResultAPI.");

            if (pDFValidationResultAPI.PdfaWarningsOption.IsSet && pDFValidationResultAPI.PdfaWarnings == null)
                throw new ArgumentNullException(nameof(pDFValidationResultAPI.PdfaWarnings), "Property is required for class PDFValidationResultAPI.");

            if (pDFValidationResultAPI.XmpErrorsOption.IsSet && pDFValidationResultAPI.XmpErrors == null)
                throw new ArgumentNullException(nameof(pDFValidationResultAPI.XmpErrors), "Property is required for class PDFValidationResultAPI.");

            if (pDFValidationResultAPI.XmpMetadataOption.IsSet && pDFValidationResultAPI.XmpMetadata == null)
                throw new ArgumentNullException(nameof(pDFValidationResultAPI.XmpMetadata), "Property is required for class PDFValidationResultAPI.");

            if (pDFValidationResultAPI.SignaturesOption.IsSet && pDFValidationResultAPI.Signatures == null)
                throw new ArgumentNullException(nameof(pDFValidationResultAPI.Signatures), "Property is required for class PDFValidationResultAPI.");

            if (pDFValidationResultAPI.SignatureErrorsOption.IsSet && pDFValidationResultAPI.SignatureErrors == null)
                throw new ArgumentNullException(nameof(pDFValidationResultAPI.SignatureErrors), "Property is required for class PDFValidationResultAPI.");

            writer.WriteBoolean("isCompliant", pDFValidationResultAPI.IsCompliant);

            writer.WriteBoolean("xmlPresent", pDFValidationResultAPI.XmlPresent);

            writer.WriteBoolean("xmlCompliant", pDFValidationResultAPI.XmlCompliant);

            writer.WriteBoolean("pdfaCompliant", pDFValidationResultAPI.PdfaCompliant);

            writer.WriteBoolean("xmpPresent", pDFValidationResultAPI.XmpPresent);

            writer.WriteBoolean("xmpFacturxCompliant", pDFValidationResultAPI.XmpFacturxCompliant);

            writer.WriteBoolean("isSigned", pDFValidationResultAPI.IsSigned);

            writer.WriteString("summaryMessage", pDFValidationResultAPI.SummaryMessage);

            if (pDFValidationResultAPI.DetectedProfileOption.IsSet)
                if (pDFValidationResultAPI.DetectedProfileOption.Value != null)
                    writer.WriteString("detectedProfile", pDFValidationResultAPI.DetectedProfile);
                else
                    writer.WriteNull("detectedProfile");

            if (pDFValidationResultAPI.XmlErrorsOption.IsSet)
            {
                writer.WritePropertyName("xmlErrors");
                JsonSerializer.Serialize(writer, pDFValidationResultAPI.XmlErrors, jsonSerializerOptions);
            }
            if (pDFValidationResultAPI.PdfaVersionOption.IsSet)
                if (pDFValidationResultAPI.PdfaVersionOption.Value != null)
                    writer.WriteString("pdfaVersion", pDFValidationResultAPI.PdfaVersion);
                else
                    writer.WriteNull("pdfaVersion");

            if (pDFValidationResultAPI.PdfaValidationMethodOption.IsSet)
                writer.WriteString("pdfaValidationMethod", pDFValidationResultAPI.PdfaValidationMethod);

            if (pDFValidationResultAPI.ValidatedRulesOption.IsSet)
                if (pDFValidationResultAPI.ValidatedRulesOption.Value != null)
                    writer.WriteNumber("validatedRules", pDFValidationResultAPI.ValidatedRulesOption.Value!.Value);
                else
                    writer.WriteNull("validatedRules");

            if (pDFValidationResultAPI.FailedRulesOption.IsSet)
                if (pDFValidationResultAPI.FailedRulesOption.Value != null)
                    writer.WriteNumber("failedRules", pDFValidationResultAPI.FailedRulesOption.Value!.Value);
                else
                    writer.WriteNull("failedRules");

            if (pDFValidationResultAPI.PdfaErrorsOption.IsSet)
            {
                writer.WritePropertyName("pdfaErrors");
                JsonSerializer.Serialize(writer, pDFValidationResultAPI.PdfaErrors, jsonSerializerOptions);
            }
            if (pDFValidationResultAPI.PdfaWarningsOption.IsSet)
            {
                writer.WritePropertyName("pdfaWarnings");
                JsonSerializer.Serialize(writer, pDFValidationResultAPI.PdfaWarnings, jsonSerializerOptions);
            }
            if (pDFValidationResultAPI.XmpProfileOption.IsSet)
                if (pDFValidationResultAPI.XmpProfileOption.Value != null)
                    writer.WriteString("xmpProfile", pDFValidationResultAPI.XmpProfile);
                else
                    writer.WriteNull("xmpProfile");

            if (pDFValidationResultAPI.XmpVersionOption.IsSet)
                if (pDFValidationResultAPI.XmpVersionOption.Value != null)
                    writer.WriteString("xmpVersion", pDFValidationResultAPI.XmpVersion);
                else
                    writer.WriteNull("xmpVersion");

            if (pDFValidationResultAPI.XmpErrorsOption.IsSet)
            {
                writer.WritePropertyName("xmpErrors");
                JsonSerializer.Serialize(writer, pDFValidationResultAPI.XmpErrors, jsonSerializerOptions);
            }
            if (pDFValidationResultAPI.XmpMetadataOption.IsSet)
            {
                writer.WritePropertyName("xmpMetadata");
                JsonSerializer.Serialize(writer, pDFValidationResultAPI.XmpMetadata, jsonSerializerOptions);
            }
            if (pDFValidationResultAPI.SignatureCountOption.IsSet)
                writer.WriteNumber("signatureCount", pDFValidationResultAPI.SignatureCountOption.Value!.Value);

            if (pDFValidationResultAPI.SignaturesOption.IsSet)
            {
                writer.WritePropertyName("signatures");
                JsonSerializer.Serialize(writer, pDFValidationResultAPI.Signatures, jsonSerializerOptions);
            }
            if (pDFValidationResultAPI.SignatureErrorsOption.IsSet)
            {
                writer.WritePropertyName("signatureErrors");
                JsonSerializer.Serialize(writer, pDFValidationResultAPI.SignatureErrors, jsonSerializerOptions);
            }
        }
    }
}
