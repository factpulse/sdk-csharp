// <auto-generated>
/*
 * API REST FactPulse
 *
 *  API REST pour la facturation √©lectronique en France : Factur-X, AFNOR PDP/PA, signatures √©lectroniques.  ## üéØ Fonctionnalit√©s principales  ### üìÑ G√©n√©ration de factures Factur-X - **Formats** : XML seul ou PDF/A-3 avec XML embarqu√© - **Profils** : MINIMUM, BASIC, EN16931, EXTENDED - **Normes** : EN 16931 (directive UE 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **üÜï Format simplifi√©** : G√©n√©ration √† partir de SIRET + auto-enrichissement (API Chorus Pro + Recherche Entreprises)  ### ‚úÖ Validation et conformit√© - **Validation XML** : Schematron (45 √† 210+ r√®gles selon profil) - **Validation PDF** : PDF/A-3, m√©tadonn√©es XMP Factur-X, signatures √©lectroniques - **VeraPDF** : Validation stricte PDF/A (146+ r√®gles ISO 19005-3) - **Traitement asynchrone** : Support Celery pour validations lourdes (VeraPDF)  ### üì° Int√©gration AFNOR PDP/PA (XP Z12-013) - **Soumission de flux** : Envoi de factures vers Plateformes de D√©mat√©rialisation Partenaires - **Recherche de flux** : Consultation des factures soumises - **T√©l√©chargement** : R√©cup√©ration des PDF/A-3 avec XML - **Directory Service** : Recherche d'entreprises (SIREN/SIRET) - **Multi-client** : Support de plusieurs configs PDP par utilisateur (stored credentials ou zero-storage)  ### ‚úçÔ∏è Signature √©lectronique PDF - **Standards** : PAdES-B-B, PAdES-B-T (horodatage RFC 3161), PAdES-B-LT (archivage long terme) - **Niveaux eIDAS** : SES (auto-sign√©), AdES (CA commerciale), QES (PSCO) - **Validation** : V√©rification int√©grit√© cryptographique et certificats - **G√©n√©ration de certificats** : Certificats X.509 auto-sign√©s pour tests  ### üîÑ Traitement asynchrone - **Celery** : G√©n√©ration, validation et signature asynchrones - **Polling** : Suivi d'√©tat via `/taches/{id_tache}/statut` - **Pas de timeout** : Id√©al pour gros fichiers ou validations lourdes  ## üîí Authentification  Toutes les requ√™tes n√©cessitent un **token JWT** dans le header Authorization : ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### Comment obtenir un token JWT ?  #### üîë M√©thode 1 : API `/api/token/` (Recommand√©e)  **URL :** `https://www.factpulse.fr/api/token/`  Cette m√©thode est **recommand√©e** pour l'int√©gration dans vos applications et workflows CI/CD.  **Pr√©requis :** Avoir d√©fini un mot de passe sur votre compte  **Pour les utilisateurs inscrits via email/password :** - Vous avez d√©j√† un mot de passe, utilisez-le directement  **Pour les utilisateurs inscrits via OAuth (Google/GitHub) :** - Vous devez d'abord d√©finir un mot de passe sur : https://www.factpulse.fr/accounts/password/set/ - Une fois le mot de passe cr√©√©, vous pourrez utiliser l'API  **Exemple de requ√™te :** ```bash curl -X POST https://www.factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"votre_email@example.com\",     \"password\": \"votre_mot_de_passe\"   }' ```  **Param√®tre optionnel `client_uid` :**  Pour s√©lectionner les credentials d'un client sp√©cifique (PA/PDP, Chorus Pro, certificats de signature), ajoutez `client_uid` :  ```bash curl -X POST https://www.factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"votre_email@example.com\",     \"password\": \"votre_mot_de_passe\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  Le `client_uid` sera inclus dans le JWT et permettra √† l'API d'utiliser automatiquement : - Les credentials AFNOR/PDP configur√©s pour ce client - Les credentials Chorus Pro configur√©s pour ce client - Les certificats de signature √©lectronique configur√©s pour ce client  **R√©ponse :** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Token d'acc√®s (validit√©: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Token de rafra√Æchissement (validit√©: 7 jours) } ```  **Avantages :** - ‚úÖ Automatisation compl√®te (CI/CD, scripts) - ‚úÖ Gestion programmatique des tokens - ‚úÖ Support du refresh token pour renouveler automatiquement l'acc√®s - ‚úÖ Int√©gration facile dans n'importe quel langage/outil  #### üñ•Ô∏è M√©thode 2 : G√©n√©ration via Dashboard (Alternative)  **URL :** https://www.factpulse.fr/dashboard/  Cette m√©thode convient pour des tests rapides ou une utilisation occasionnelle via l'interface graphique.  **Fonctionnement :** - Connectez-vous au dashboard - Utilisez les boutons \"Generate Test Token\" ou \"Generate Production Token\" - Fonctionne pour **tous** les utilisateurs (OAuth et email/password), sans n√©cessiter de mot de passe  **Types de tokens :** - **Token Test** : Validit√© 24h, quota 1000 appels/jour (gratuit) - **Token Production** : Validit√© 7 jours, quota selon votre forfait  **Avantages :** - ‚úÖ Rapide pour tester l'API - ‚úÖ Aucun mot de passe requis - ‚úÖ Interface visuelle simple  **Inconv√©nients :** - ‚ùå N√©cessite une action manuelle - ‚ùå Pas de refresh token - ‚ùå Moins adapt√© pour l'automatisation  ### üìö Documentation compl√®te  Pour plus d'informations sur l'authentification et l'utilisation de l'API : https://www.factpulse.fr/documentation-api/     
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using FactPulse.SDK.Client;

namespace FactPulse.SDK.Model
{
    /// <summary>
    /// R√©sultat complet de la validation d&#39;un PDF Factur-X.
    /// </summary>
    public partial class ResultatValidationPDFAPI : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ResultatValidationPDFAPI" /> class.
        /// </summary>
        /// <param name="estConforme">True si le PDF est conforme √† tous les crit√®res (XML, PDF/A, XMP)</param>
        /// <param name="xmlPresent">True si un XML Factur-X est embarqu√© dans le PDF</param>
        /// <param name="xmlConforme">True si le XML Factur-X est conforme aux r√®gles Schematron</param>
        /// <param name="pdfaConforme">True si le PDF est conforme PDF/A</param>
        /// <param name="xmpPresent">True si des m√©tadonn√©es XMP sont pr√©sentes</param>
        /// <param name="xmpConformeFacturx">True si les m√©tadonn√©es XMP contiennent des informations Factur-X</param>
        /// <param name="estSigne">True si le PDF contient au moins une signature</param>
        /// <param name="messageResume">Message r√©sumant le r√©sultat de la validation</param>
        /// <param name="profilDetecte">profilDetecte</param>
        /// <param name="erreursXml">Liste des erreurs de validation XML</param>
        /// <param name="versionPdfa">versionPdfa</param>
        /// <param name="methodeValidationPdfa">M√©thode utilis√©e pour la validation PDF/A (metadata ou verapdf) (default to &quot;metadata&quot;)</param>
        /// <param name="reglesValidees">reglesValidees</param>
        /// <param name="reglesEchouees">reglesEchouees</param>
        /// <param name="erreursPdfa">Liste des erreurs de conformit√© PDF/A</param>
        /// <param name="avertissementsPdfa">Liste des avertissements PDF/A</param>
        /// <param name="profilXmp">profilXmp</param>
        /// <param name="versionXmp">versionXmp</param>
        /// <param name="erreursXmp">Liste des erreurs de m√©tadonn√©es XMP</param>
        /// <param name="metadonneesXmp">M√©tadonn√©es XMP extraites du PDF</param>
        /// <param name="nombreSignatures">Nombre de signatures √©lectroniques trouv√©es (default to 0)</param>
        /// <param name="signatures">Liste des signatures trouv√©es avec leurs informations</param>
        /// <param name="erreursSignatures">Liste des erreurs lors de l&#39;analyse des signatures</param>
        [JsonConstructor]
        public ResultatValidationPDFAPI(bool estConforme, bool xmlPresent, bool xmlConforme, bool pdfaConforme, bool xmpPresent, bool xmpConformeFacturx, bool estSigne, string messageResume, Option<string?> profilDetecte = default, Option<List<string>?> erreursXml = default, Option<string?> versionPdfa = default, Option<string?> methodeValidationPdfa = default, Option<int?> reglesValidees = default, Option<int?> reglesEchouees = default, Option<List<string>?> erreursPdfa = default, Option<List<string>?> avertissementsPdfa = default, Option<string?> profilXmp = default, Option<string?> versionXmp = default, Option<List<string>?> erreursXmp = default, Option<Dictionary<string, Object>?> metadonneesXmp = default, Option<int?> nombreSignatures = default, Option<List<InformationSignatureAPI>?> signatures = default, Option<List<string>?> erreursSignatures = default)
        {
            EstConforme = estConforme;
            XmlPresent = xmlPresent;
            XmlConforme = xmlConforme;
            PdfaConforme = pdfaConforme;
            XmpPresent = xmpPresent;
            XmpConformeFacturx = xmpConformeFacturx;
            EstSigne = estSigne;
            MessageResume = messageResume;
            ProfilDetecteOption = profilDetecte;
            ErreursXmlOption = erreursXml;
            VersionPdfaOption = versionPdfa;
            MethodeValidationPdfaOption = methodeValidationPdfa;
            ReglesValideesOption = reglesValidees;
            ReglesEchoueesOption = reglesEchouees;
            ErreursPdfaOption = erreursPdfa;
            AvertissementsPdfaOption = avertissementsPdfa;
            ProfilXmpOption = profilXmp;
            VersionXmpOption = versionXmp;
            ErreursXmpOption = erreursXmp;
            MetadonneesXmpOption = metadonneesXmp;
            NombreSignaturesOption = nombreSignatures;
            SignaturesOption = signatures;
            ErreursSignaturesOption = erreursSignatures;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// True si le PDF est conforme √† tous les crit√®res (XML, PDF/A, XMP)
        /// </summary>
        /// <value>True si le PDF est conforme √† tous les crit√®res (XML, PDF/A, XMP)</value>
        [JsonPropertyName("est_conforme")]
        public bool EstConforme { get; set; }

        /// <summary>
        /// True si un XML Factur-X est embarqu√© dans le PDF
        /// </summary>
        /// <value>True si un XML Factur-X est embarqu√© dans le PDF</value>
        [JsonPropertyName("xml_present")]
        public bool XmlPresent { get; set; }

        /// <summary>
        /// True si le XML Factur-X est conforme aux r√®gles Schematron
        /// </summary>
        /// <value>True si le XML Factur-X est conforme aux r√®gles Schematron</value>
        [JsonPropertyName("xml_conforme")]
        public bool XmlConforme { get; set; }

        /// <summary>
        /// True si le PDF est conforme PDF/A
        /// </summary>
        /// <value>True si le PDF est conforme PDF/A</value>
        [JsonPropertyName("pdfa_conforme")]
        public bool PdfaConforme { get; set; }

        /// <summary>
        /// True si des m√©tadonn√©es XMP sont pr√©sentes
        /// </summary>
        /// <value>True si des m√©tadonn√©es XMP sont pr√©sentes</value>
        [JsonPropertyName("xmp_present")]
        public bool XmpPresent { get; set; }

        /// <summary>
        /// True si les m√©tadonn√©es XMP contiennent des informations Factur-X
        /// </summary>
        /// <value>True si les m√©tadonn√©es XMP contiennent des informations Factur-X</value>
        [JsonPropertyName("xmp_conforme_facturx")]
        public bool XmpConformeFacturx { get; set; }

        /// <summary>
        /// True si le PDF contient au moins une signature
        /// </summary>
        /// <value>True si le PDF contient au moins une signature</value>
        [JsonPropertyName("est_signe")]
        public bool EstSigne { get; set; }

        /// <summary>
        /// Message r√©sumant le r√©sultat de la validation
        /// </summary>
        /// <value>Message r√©sumant le r√©sultat de la validation</value>
        [JsonPropertyName("message_resume")]
        public string MessageResume { get; set; }

        /// <summary>
        /// Used to track the state of ProfilDetecte
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ProfilDetecteOption { get; private set; }

        /// <summary>
        /// Gets or Sets ProfilDetecte
        /// </summary>
        [JsonPropertyName("profil_detecte")]
        public string? ProfilDetecte { get { return this.ProfilDetecteOption; } set { this.ProfilDetecteOption = new(value); } }

        /// <summary>
        /// Used to track the state of ErreursXml
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> ErreursXmlOption { get; private set; }

        /// <summary>
        /// Liste des erreurs de validation XML
        /// </summary>
        /// <value>Liste des erreurs de validation XML</value>
        [JsonPropertyName("erreurs_xml")]
        public List<string>? ErreursXml { get { return this.ErreursXmlOption; } set { this.ErreursXmlOption = new(value); } }

        /// <summary>
        /// Used to track the state of VersionPdfa
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> VersionPdfaOption { get; private set; }

        /// <summary>
        /// Gets or Sets VersionPdfa
        /// </summary>
        [JsonPropertyName("version_pdfa")]
        public string? VersionPdfa { get { return this.VersionPdfaOption; } set { this.VersionPdfaOption = new(value); } }

        /// <summary>
        /// Used to track the state of MethodeValidationPdfa
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> MethodeValidationPdfaOption { get; private set; }

        /// <summary>
        /// M√©thode utilis√©e pour la validation PDF/A (metadata ou verapdf)
        /// </summary>
        /// <value>M√©thode utilis√©e pour la validation PDF/A (metadata ou verapdf)</value>
        [JsonPropertyName("methode_validation_pdfa")]
        public string? MethodeValidationPdfa { get { return this.MethodeValidationPdfaOption; } set { this.MethodeValidationPdfaOption = new(value); } }

        /// <summary>
        /// Used to track the state of ReglesValidees
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> ReglesValideesOption { get; private set; }

        /// <summary>
        /// Gets or Sets ReglesValidees
        /// </summary>
        [JsonPropertyName("regles_validees")]
        public int? ReglesValidees { get { return this.ReglesValideesOption; } set { this.ReglesValideesOption = new(value); } }

        /// <summary>
        /// Used to track the state of ReglesEchouees
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> ReglesEchoueesOption { get; private set; }

        /// <summary>
        /// Gets or Sets ReglesEchouees
        /// </summary>
        [JsonPropertyName("regles_echouees")]
        public int? ReglesEchouees { get { return this.ReglesEchoueesOption; } set { this.ReglesEchoueesOption = new(value); } }

        /// <summary>
        /// Used to track the state of ErreursPdfa
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> ErreursPdfaOption { get; private set; }

        /// <summary>
        /// Liste des erreurs de conformit√© PDF/A
        /// </summary>
        /// <value>Liste des erreurs de conformit√© PDF/A</value>
        [JsonPropertyName("erreurs_pdfa")]
        public List<string>? ErreursPdfa { get { return this.ErreursPdfaOption; } set { this.ErreursPdfaOption = new(value); } }

        /// <summary>
        /// Used to track the state of AvertissementsPdfa
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> AvertissementsPdfaOption { get; private set; }

        /// <summary>
        /// Liste des avertissements PDF/A
        /// </summary>
        /// <value>Liste des avertissements PDF/A</value>
        [JsonPropertyName("avertissements_pdfa")]
        public List<string>? AvertissementsPdfa { get { return this.AvertissementsPdfaOption; } set { this.AvertissementsPdfaOption = new(value); } }

        /// <summary>
        /// Used to track the state of ProfilXmp
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ProfilXmpOption { get; private set; }

        /// <summary>
        /// Gets or Sets ProfilXmp
        /// </summary>
        [JsonPropertyName("profil_xmp")]
        public string? ProfilXmp { get { return this.ProfilXmpOption; } set { this.ProfilXmpOption = new(value); } }

        /// <summary>
        /// Used to track the state of VersionXmp
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> VersionXmpOption { get; private set; }

        /// <summary>
        /// Gets or Sets VersionXmp
        /// </summary>
        [JsonPropertyName("version_xmp")]
        public string? VersionXmp { get { return this.VersionXmpOption; } set { this.VersionXmpOption = new(value); } }

        /// <summary>
        /// Used to track the state of ErreursXmp
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> ErreursXmpOption { get; private set; }

        /// <summary>
        /// Liste des erreurs de m√©tadonn√©es XMP
        /// </summary>
        /// <value>Liste des erreurs de m√©tadonn√©es XMP</value>
        [JsonPropertyName("erreurs_xmp")]
        public List<string>? ErreursXmp { get { return this.ErreursXmpOption; } set { this.ErreursXmpOption = new(value); } }

        /// <summary>
        /// Used to track the state of MetadonneesXmp
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, Object>?> MetadonneesXmpOption { get; private set; }

        /// <summary>
        /// M√©tadonn√©es XMP extraites du PDF
        /// </summary>
        /// <value>M√©tadonn√©es XMP extraites du PDF</value>
        [JsonPropertyName("metadonnees_xmp")]
        public Dictionary<string, Object>? MetadonneesXmp { get { return this.MetadonneesXmpOption; } set { this.MetadonneesXmpOption = new(value); } }

        /// <summary>
        /// Used to track the state of NombreSignatures
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> NombreSignaturesOption { get; private set; }

        /// <summary>
        /// Nombre de signatures √©lectroniques trouv√©es
        /// </summary>
        /// <value>Nombre de signatures √©lectroniques trouv√©es</value>
        [JsonPropertyName("nombre_signatures")]
        public int? NombreSignatures { get { return this.NombreSignaturesOption; } set { this.NombreSignaturesOption = new(value); } }

        /// <summary>
        /// Used to track the state of Signatures
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<InformationSignatureAPI>?> SignaturesOption { get; private set; }

        /// <summary>
        /// Liste des signatures trouv√©es avec leurs informations
        /// </summary>
        /// <value>Liste des signatures trouv√©es avec leurs informations</value>
        [JsonPropertyName("signatures")]
        public List<InformationSignatureAPI>? Signatures { get { return this.SignaturesOption; } set { this.SignaturesOption = new(value); } }

        /// <summary>
        /// Used to track the state of ErreursSignatures
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> ErreursSignaturesOption { get; private set; }

        /// <summary>
        /// Liste des erreurs lors de l&#39;analyse des signatures
        /// </summary>
        /// <value>Liste des erreurs lors de l&#39;analyse des signatures</value>
        [JsonPropertyName("erreurs_signatures")]
        public List<string>? ErreursSignatures { get { return this.ErreursSignaturesOption; } set { this.ErreursSignaturesOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ResultatValidationPDFAPI {\n");
            sb.Append("  EstConforme: ").Append(EstConforme).Append("\n");
            sb.Append("  XmlPresent: ").Append(XmlPresent).Append("\n");
            sb.Append("  XmlConforme: ").Append(XmlConforme).Append("\n");
            sb.Append("  PdfaConforme: ").Append(PdfaConforme).Append("\n");
            sb.Append("  XmpPresent: ").Append(XmpPresent).Append("\n");
            sb.Append("  XmpConformeFacturx: ").Append(XmpConformeFacturx).Append("\n");
            sb.Append("  EstSigne: ").Append(EstSigne).Append("\n");
            sb.Append("  MessageResume: ").Append(MessageResume).Append("\n");
            sb.Append("  ProfilDetecte: ").Append(ProfilDetecte).Append("\n");
            sb.Append("  ErreursXml: ").Append(ErreursXml).Append("\n");
            sb.Append("  VersionPdfa: ").Append(VersionPdfa).Append("\n");
            sb.Append("  MethodeValidationPdfa: ").Append(MethodeValidationPdfa).Append("\n");
            sb.Append("  ReglesValidees: ").Append(ReglesValidees).Append("\n");
            sb.Append("  ReglesEchouees: ").Append(ReglesEchouees).Append("\n");
            sb.Append("  ErreursPdfa: ").Append(ErreursPdfa).Append("\n");
            sb.Append("  AvertissementsPdfa: ").Append(AvertissementsPdfa).Append("\n");
            sb.Append("  ProfilXmp: ").Append(ProfilXmp).Append("\n");
            sb.Append("  VersionXmp: ").Append(VersionXmp).Append("\n");
            sb.Append("  ErreursXmp: ").Append(ErreursXmp).Append("\n");
            sb.Append("  MetadonneesXmp: ").Append(MetadonneesXmp).Append("\n");
            sb.Append("  NombreSignatures: ").Append(NombreSignatures).Append("\n");
            sb.Append("  Signatures: ").Append(Signatures).Append("\n");
            sb.Append("  ErreursSignatures: ").Append(ErreursSignatures).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="ResultatValidationPDFAPI" />
    /// </summary>
    public class ResultatValidationPDFAPIJsonConverter : JsonConverter<ResultatValidationPDFAPI>
    {
        /// <summary>
        /// Deserializes json to <see cref="ResultatValidationPDFAPI" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override ResultatValidationPDFAPI Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<bool?> estConforme = default;
            Option<bool?> xmlPresent = default;
            Option<bool?> xmlConforme = default;
            Option<bool?> pdfaConforme = default;
            Option<bool?> xmpPresent = default;
            Option<bool?> xmpConformeFacturx = default;
            Option<bool?> estSigne = default;
            Option<string?> messageResume = default;
            Option<string?> profilDetecte = default;
            Option<List<string>?> erreursXml = default;
            Option<string?> versionPdfa = default;
            Option<string?> methodeValidationPdfa = default;
            Option<int?> reglesValidees = default;
            Option<int?> reglesEchouees = default;
            Option<List<string>?> erreursPdfa = default;
            Option<List<string>?> avertissementsPdfa = default;
            Option<string?> profilXmp = default;
            Option<string?> versionXmp = default;
            Option<List<string>?> erreursXmp = default;
            Option<Dictionary<string, Object>?> metadonneesXmp = default;
            Option<int?> nombreSignatures = default;
            Option<List<InformationSignatureAPI>?> signatures = default;
            Option<List<string>?> erreursSignatures = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "est_conforme":
                            estConforme = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "xml_present":
                            xmlPresent = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "xml_conforme":
                            xmlConforme = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "pdfa_conforme":
                            pdfaConforme = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "xmp_present":
                            xmpPresent = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "xmp_conforme_facturx":
                            xmpConformeFacturx = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "est_signe":
                            estSigne = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "message_resume":
                            messageResume = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "profil_detecte":
                            profilDetecte = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "erreurs_xml":
                            erreursXml = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "version_pdfa":
                            versionPdfa = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "methode_validation_pdfa":
                            methodeValidationPdfa = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "regles_validees":
                            reglesValidees = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "regles_echouees":
                            reglesEchouees = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "erreurs_pdfa":
                            erreursPdfa = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "avertissements_pdfa":
                            avertissementsPdfa = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "profil_xmp":
                            profilXmp = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "version_xmp":
                            versionXmp = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "erreurs_xmp":
                            erreursXmp = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "metadonnees_xmp":
                            metadonneesXmp = new Option<Dictionary<string, Object>?>(JsonSerializer.Deserialize<Dictionary<string, Object>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "nombre_signatures":
                            nombreSignatures = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "signatures":
                            signatures = new Option<List<InformationSignatureAPI>?>(JsonSerializer.Deserialize<List<InformationSignatureAPI>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "erreurs_signatures":
                            erreursSignatures = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!estConforme.IsSet)
                throw new ArgumentException("Property is required for class ResultatValidationPDFAPI.", nameof(estConforme));

            if (!xmlPresent.IsSet)
                throw new ArgumentException("Property is required for class ResultatValidationPDFAPI.", nameof(xmlPresent));

            if (!xmlConforme.IsSet)
                throw new ArgumentException("Property is required for class ResultatValidationPDFAPI.", nameof(xmlConforme));

            if (!pdfaConforme.IsSet)
                throw new ArgumentException("Property is required for class ResultatValidationPDFAPI.", nameof(pdfaConforme));

            if (!xmpPresent.IsSet)
                throw new ArgumentException("Property is required for class ResultatValidationPDFAPI.", nameof(xmpPresent));

            if (!xmpConformeFacturx.IsSet)
                throw new ArgumentException("Property is required for class ResultatValidationPDFAPI.", nameof(xmpConformeFacturx));

            if (!estSigne.IsSet)
                throw new ArgumentException("Property is required for class ResultatValidationPDFAPI.", nameof(estSigne));

            if (!messageResume.IsSet)
                throw new ArgumentException("Property is required for class ResultatValidationPDFAPI.", nameof(messageResume));

            if (estConforme.IsSet && estConforme.Value == null)
                throw new ArgumentNullException(nameof(estConforme), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (xmlPresent.IsSet && xmlPresent.Value == null)
                throw new ArgumentNullException(nameof(xmlPresent), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (xmlConforme.IsSet && xmlConforme.Value == null)
                throw new ArgumentNullException(nameof(xmlConforme), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (pdfaConforme.IsSet && pdfaConforme.Value == null)
                throw new ArgumentNullException(nameof(pdfaConforme), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (xmpPresent.IsSet && xmpPresent.Value == null)
                throw new ArgumentNullException(nameof(xmpPresent), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (xmpConformeFacturx.IsSet && xmpConformeFacturx.Value == null)
                throw new ArgumentNullException(nameof(xmpConformeFacturx), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (estSigne.IsSet && estSigne.Value == null)
                throw new ArgumentNullException(nameof(estSigne), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (messageResume.IsSet && messageResume.Value == null)
                throw new ArgumentNullException(nameof(messageResume), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (erreursXml.IsSet && erreursXml.Value == null)
                throw new ArgumentNullException(nameof(erreursXml), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (methodeValidationPdfa.IsSet && methodeValidationPdfa.Value == null)
                throw new ArgumentNullException(nameof(methodeValidationPdfa), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (erreursPdfa.IsSet && erreursPdfa.Value == null)
                throw new ArgumentNullException(nameof(erreursPdfa), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (avertissementsPdfa.IsSet && avertissementsPdfa.Value == null)
                throw new ArgumentNullException(nameof(avertissementsPdfa), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (erreursXmp.IsSet && erreursXmp.Value == null)
                throw new ArgumentNullException(nameof(erreursXmp), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (metadonneesXmp.IsSet && metadonneesXmp.Value == null)
                throw new ArgumentNullException(nameof(metadonneesXmp), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (nombreSignatures.IsSet && nombreSignatures.Value == null)
                throw new ArgumentNullException(nameof(nombreSignatures), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (signatures.IsSet && signatures.Value == null)
                throw new ArgumentNullException(nameof(signatures), "Property is not nullable for class ResultatValidationPDFAPI.");

            if (erreursSignatures.IsSet && erreursSignatures.Value == null)
                throw new ArgumentNullException(nameof(erreursSignatures), "Property is not nullable for class ResultatValidationPDFAPI.");

            return new ResultatValidationPDFAPI(estConforme.Value!.Value!, xmlPresent.Value!.Value!, xmlConforme.Value!.Value!, pdfaConforme.Value!.Value!, xmpPresent.Value!.Value!, xmpConformeFacturx.Value!.Value!, estSigne.Value!.Value!, messageResume.Value!, profilDetecte, erreursXml, versionPdfa, methodeValidationPdfa, reglesValidees, reglesEchouees, erreursPdfa, avertissementsPdfa, profilXmp, versionXmp, erreursXmp, metadonneesXmp, nombreSignatures, signatures, erreursSignatures);
        }

        /// <summary>
        /// Serializes a <see cref="ResultatValidationPDFAPI" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="resultatValidationPDFAPI"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, ResultatValidationPDFAPI resultatValidationPDFAPI, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, resultatValidationPDFAPI, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="ResultatValidationPDFAPI" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="resultatValidationPDFAPI"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, ResultatValidationPDFAPI resultatValidationPDFAPI, JsonSerializerOptions jsonSerializerOptions)
        {
            if (resultatValidationPDFAPI.MessageResume == null)
                throw new ArgumentNullException(nameof(resultatValidationPDFAPI.MessageResume), "Property is required for class ResultatValidationPDFAPI.");

            if (resultatValidationPDFAPI.ErreursXmlOption.IsSet && resultatValidationPDFAPI.ErreursXml == null)
                throw new ArgumentNullException(nameof(resultatValidationPDFAPI.ErreursXml), "Property is required for class ResultatValidationPDFAPI.");

            if (resultatValidationPDFAPI.MethodeValidationPdfaOption.IsSet && resultatValidationPDFAPI.MethodeValidationPdfa == null)
                throw new ArgumentNullException(nameof(resultatValidationPDFAPI.MethodeValidationPdfa), "Property is required for class ResultatValidationPDFAPI.");

            if (resultatValidationPDFAPI.ErreursPdfaOption.IsSet && resultatValidationPDFAPI.ErreursPdfa == null)
                throw new ArgumentNullException(nameof(resultatValidationPDFAPI.ErreursPdfa), "Property is required for class ResultatValidationPDFAPI.");

            if (resultatValidationPDFAPI.AvertissementsPdfaOption.IsSet && resultatValidationPDFAPI.AvertissementsPdfa == null)
                throw new ArgumentNullException(nameof(resultatValidationPDFAPI.AvertissementsPdfa), "Property is required for class ResultatValidationPDFAPI.");

            if (resultatValidationPDFAPI.ErreursXmpOption.IsSet && resultatValidationPDFAPI.ErreursXmp == null)
                throw new ArgumentNullException(nameof(resultatValidationPDFAPI.ErreursXmp), "Property is required for class ResultatValidationPDFAPI.");

            if (resultatValidationPDFAPI.MetadonneesXmpOption.IsSet && resultatValidationPDFAPI.MetadonneesXmp == null)
                throw new ArgumentNullException(nameof(resultatValidationPDFAPI.MetadonneesXmp), "Property is required for class ResultatValidationPDFAPI.");

            if (resultatValidationPDFAPI.SignaturesOption.IsSet && resultatValidationPDFAPI.Signatures == null)
                throw new ArgumentNullException(nameof(resultatValidationPDFAPI.Signatures), "Property is required for class ResultatValidationPDFAPI.");

            if (resultatValidationPDFAPI.ErreursSignaturesOption.IsSet && resultatValidationPDFAPI.ErreursSignatures == null)
                throw new ArgumentNullException(nameof(resultatValidationPDFAPI.ErreursSignatures), "Property is required for class ResultatValidationPDFAPI.");

            writer.WriteBoolean("est_conforme", resultatValidationPDFAPI.EstConforme);

            writer.WriteBoolean("xml_present", resultatValidationPDFAPI.XmlPresent);

            writer.WriteBoolean("xml_conforme", resultatValidationPDFAPI.XmlConforme);

            writer.WriteBoolean("pdfa_conforme", resultatValidationPDFAPI.PdfaConforme);

            writer.WriteBoolean("xmp_present", resultatValidationPDFAPI.XmpPresent);

            writer.WriteBoolean("xmp_conforme_facturx", resultatValidationPDFAPI.XmpConformeFacturx);

            writer.WriteBoolean("est_signe", resultatValidationPDFAPI.EstSigne);

            writer.WriteString("message_resume", resultatValidationPDFAPI.MessageResume);

            if (resultatValidationPDFAPI.ProfilDetecteOption.IsSet)
                if (resultatValidationPDFAPI.ProfilDetecteOption.Value != null)
                    writer.WriteString("profil_detecte", resultatValidationPDFAPI.ProfilDetecte);
                else
                    writer.WriteNull("profil_detecte");

            if (resultatValidationPDFAPI.ErreursXmlOption.IsSet)
            {
                writer.WritePropertyName("erreurs_xml");
                JsonSerializer.Serialize(writer, resultatValidationPDFAPI.ErreursXml, jsonSerializerOptions);
            }
            if (resultatValidationPDFAPI.VersionPdfaOption.IsSet)
                if (resultatValidationPDFAPI.VersionPdfaOption.Value != null)
                    writer.WriteString("version_pdfa", resultatValidationPDFAPI.VersionPdfa);
                else
                    writer.WriteNull("version_pdfa");

            if (resultatValidationPDFAPI.MethodeValidationPdfaOption.IsSet)
                writer.WriteString("methode_validation_pdfa", resultatValidationPDFAPI.MethodeValidationPdfa);

            if (resultatValidationPDFAPI.ReglesValideesOption.IsSet)
                if (resultatValidationPDFAPI.ReglesValideesOption.Value != null)
                    writer.WriteNumber("regles_validees", resultatValidationPDFAPI.ReglesValideesOption.Value!.Value);
                else
                    writer.WriteNull("regles_validees");

            if (resultatValidationPDFAPI.ReglesEchoueesOption.IsSet)
                if (resultatValidationPDFAPI.ReglesEchoueesOption.Value != null)
                    writer.WriteNumber("regles_echouees", resultatValidationPDFAPI.ReglesEchoueesOption.Value!.Value);
                else
                    writer.WriteNull("regles_echouees");

            if (resultatValidationPDFAPI.ErreursPdfaOption.IsSet)
            {
                writer.WritePropertyName("erreurs_pdfa");
                JsonSerializer.Serialize(writer, resultatValidationPDFAPI.ErreursPdfa, jsonSerializerOptions);
            }
            if (resultatValidationPDFAPI.AvertissementsPdfaOption.IsSet)
            {
                writer.WritePropertyName("avertissements_pdfa");
                JsonSerializer.Serialize(writer, resultatValidationPDFAPI.AvertissementsPdfa, jsonSerializerOptions);
            }
            if (resultatValidationPDFAPI.ProfilXmpOption.IsSet)
                if (resultatValidationPDFAPI.ProfilXmpOption.Value != null)
                    writer.WriteString("profil_xmp", resultatValidationPDFAPI.ProfilXmp);
                else
                    writer.WriteNull("profil_xmp");

            if (resultatValidationPDFAPI.VersionXmpOption.IsSet)
                if (resultatValidationPDFAPI.VersionXmpOption.Value != null)
                    writer.WriteString("version_xmp", resultatValidationPDFAPI.VersionXmp);
                else
                    writer.WriteNull("version_xmp");

            if (resultatValidationPDFAPI.ErreursXmpOption.IsSet)
            {
                writer.WritePropertyName("erreurs_xmp");
                JsonSerializer.Serialize(writer, resultatValidationPDFAPI.ErreursXmp, jsonSerializerOptions);
            }
            if (resultatValidationPDFAPI.MetadonneesXmpOption.IsSet)
            {
                writer.WritePropertyName("metadonnees_xmp");
                JsonSerializer.Serialize(writer, resultatValidationPDFAPI.MetadonneesXmp, jsonSerializerOptions);
            }
            if (resultatValidationPDFAPI.NombreSignaturesOption.IsSet)
                writer.WriteNumber("nombre_signatures", resultatValidationPDFAPI.NombreSignaturesOption.Value!.Value);

            if (resultatValidationPDFAPI.SignaturesOption.IsSet)
            {
                writer.WritePropertyName("signatures");
                JsonSerializer.Serialize(writer, resultatValidationPDFAPI.Signatures, jsonSerializerOptions);
            }
            if (resultatValidationPDFAPI.ErreursSignaturesOption.IsSet)
            {
                writer.WritePropertyName("erreurs_signatures");
                JsonSerializer.Serialize(writer, resultatValidationPDFAPI.ErreursSignatures, jsonSerializerOptions);
            }
        }
    }
}
